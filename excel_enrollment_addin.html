<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enrollment Data Processor v3.2 COMPLETE</title>
    <script src="https://appsforoffice.microsoft.com/lib/1/hosted/office.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        
        .container {
            max-width: 400px;
            margin: 0 auto;
            background: white;
            padding: 25px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .logo {
            text-align: center;
            margin-bottom: 20px;
            font-weight: bold;
            font-size: 28px;
            letter-spacing: 2px;
        }
        
        .logo-united {
            color: #0078d4;
        }
        
        .logo-enroll {
            color: #106ebe;
        }
        
        h1 {
            color: #0078d4;
            text-align: center;
            margin-bottom: 30px;
            font-size: 20px;
        }
        
        .date-input-section {
            margin-bottom: 25px;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 4px;
            border-left: 4px solid #0078d4;
        }
        
        .date-input-section label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #495057;
        }
        
        .date-input-section input[type="date"] {
            width: 100%;
            padding: 8px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-size: 14px;
        }
        
        .date-input-section .help-text {
            margin-top: 5px;
            font-size: 12px;
            color: #6c757d;
        }
        
        .button {
            background-color: #0078d4;
            color: white;
            border: none;
            padding: 12px 24px;
            font-size: 16px;
            border-radius: 4px;
            cursor: pointer;
            width: 100%;
            margin: 10px 0;
            transition: background-color 0.3s;
        }
        
        .button:hover {
            background-color: #106ebe;
        }
        
        .button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        
        .button.step1 {
            background-color: #28a745;
        }
        
        .button.step1:hover {
            background-color: #218838;
        }
        
        .button.step2 {
            background-color: #0078d4;
        }
        
        .button.step2:hover {
            background-color: #106ebe;
        }
        
        .button.open-enrollment {
            background-color: #28a745;
        }
        
        .button.open-enrollment:hover {
            background-color: #218838;
        }
        
        .status {
            margin-top: 20px;
            padding: 15px;
            border-radius: 4px;
            font-size: 14px;
            line-height: 1.5;
        }
        
        .status.success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .status.error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        
        .status.info {
            background-color: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        
        .field-selection {
            margin: 15px 0;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 4px;
            font-size: 14px;
            display: none;
        }
        
        .field-group {
            margin-bottom: 20px;
        }
        
        .field-group h3 {
            margin: 0 0 10px 0;
            color: #495057;
            font-size: 16px;
        }
        
        .field-checkbox {
            margin: 8px 0;
            display: flex;
            align-items: center;
        }
        
        .field-checkbox input[type="checkbox"] {
            margin-right: 8px;
            transform: scale(1.2);
        }
        
        .field-checkbox label {
            cursor: pointer;
            user-select: none;
            color: #495057;
        }
        
        .field-checkbox.highlighted {
            background-color: #fff3cd;
            padding: 5px;
            border-radius: 4px;
            border-left: 4px solid #ffc107;
        }
        
        .progress {
            width: 100%;
            height: 20px;
            background-color: #e9ecef;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }
        
        .progress-bar {
            height: 100%;
            background-color: #0078d4;
            width: 0%;
            transition: width 0.3s;
        }
        
        .step-indicator {
            text-align: center;
            margin-bottom: 20px;
            font-size: 14px;
            color: #6c757d;
        }
        
        .step {
            display: inline-block;
            padding: 5px 10px;
            margin: 0 5px;
            border-radius: 15px;
            background-color: #e9ecef;
        }
        
        .step.active {
            background-color: #0078d4;
            color: white;
        }
        
        .step.completed {
            background-color: #28a745;
            color: white;
        }
        
        .date-info {
            margin: 10px 0;
            padding: 10px;
            background-color: #e3f2fd;
            border-radius: 4px;
            font-size: 12px;
        }
        
        .zero-null-info {
            margin: 10px 0;
            padding: 10px;
            background-color: #fff3cd;
            border-radius: 4px;
            font-size: 12px;
            border-left: 4px solid #ffc107;
        }
        
        .debug-info {
            margin: 10px 0;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 4px;
            font-size: 11px;
            color: #6c757d;
            border: 1px solid #dee2e6;
        }
        
        .audit-section {
            margin: 15px 0;
            padding: 15px;
            background-color: #f8d7da;
            border-radius: 4px;
            border-left: 4px solid #dc3545;
            display: none;
        }
        
        .sheet-selection {
            margin: 10px 0;
        }
        
        .sheet-selection h4 {
            margin: 0 0 10px 0;
            color: #495057;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="logo">
            <span class="logo-united">UNITED</span>
            <span class="logo-enroll">ENROLL</span>
        </div>
        <h1>Enrollment Data Processor v3.2</h1>
        
        <div class="date-input-section">
            <label for="policyDate">Policy Change Date:</label>
            <input type="date" id="policyDate" required>
            <div class="help-text">Select the specific date when policy changes occurred</div>
        </div>
        
        <div class="step-indicator">
            <span class="step" id="step1Indicator">1</span>
            <span class="step" id="step2Indicator">2</span>
        </div>
        
        <button class="button step1" id="analyzeBtn" type="button">
            Step 1: Analyze
        </button>
        
        <div id="fieldSelection" class="field-selection">
            <div class="field-group">
                <h3>SSN Fields Found:</h3>
                <div id="ssnFieldCheckboxes"></div>
                <div class="date-info">
                    <strong>Note:</strong> Only one SSN field should be selected.
                </div>
            </div>
            
            <div id="dateFieldsInfo" class="date-info">
                <strong>Date Fields Detected:</strong> <span id="dateFieldsList"></span><br>
                <em>All date fields will be checked for the specified policy date.</em>
            </div>
            
            <div id="costFieldsInfo" class="date-info">
                <strong>Cost Fields Detected:</strong> <span id="costFieldsList"></span><br>
                <em>Cost fields will be checked for values greater than $0.</em>
            </div>
            
            <div class="zero-null-info">
                <strong>Simplified Logic v3.2:</strong> 
                <ul style="margin: 5px 0; padding-left: 20px;">
                    <li><strong>EXCLUDE:</strong> SSNs where ALL rows have cost > $0 AND ALL date fields are NOT in the target date range</li>
                    <li><strong>INCLUDE:</strong> All other SSN combinations (ANY date match OR ANY zero/null cost OR ANY zero/null date)</li>
                    <li>Multiple rows per SSN consolidated into ONE row with combined data</li>
                    <li>Dollar amounts summed across all rows per SSN</li>
                    <li>Plan/coverage fields show costs as "Plan Name ($Cost) | Plan Name ($Cost)"</li>
                    <li><strong>NEW v3.2:</strong> Open Enrollment mode with SSN field selection for each sheet</li>
                </ul>
            </div>
        </div>
        
        <button class="button step2" id="processBtn" type="button" disabled>
            Step 2: Process
        </button>
        
        <button class="button open-enrollment" id="openEnrollmentBtn" type="button" style="display: none;" disabled>
            Step 2: Open Enrollment
        </button>
        
        <div id="auditSection" class="audit-section">
            <h3>Open Enrollment Configuration</h3>
            <div class="sheet-selection">
                <h4 id="sheet1Name">Sheet 1 SSN Field:</h4>
                <div id="sheet1SSNFields"></div>
            </div>
            <div class="sheet-selection">
                <h4 id="sheet2Name">Sheet 2 SSN Field:</h4>
                <div id="sheet2SSNFields"></div>
            </div>
            <div class="date-info">
                <strong>Open Enrollment Process:</strong> Matches abbreviated coverage types from Sheet 2 to full names in Sheet 1, showing OLD vs NEW coverage with costs.
            </div>
        </div>
        
        <div class="progress" id="progressContainer" style="display: none;">
            <div class="progress-bar" id="progressBar"></div>
        </div>
        
        <div id="status" class="status" style="display: none;"></div>
        
        <div id="debugInfo" class="debug-info" style="display: none;"></div>
    </div>

    <script>
        console.log('=== SCRIPT LOADING - VERSION 3.0 COMPLETE ===');
        
        let detectedHeaders = [];
        let currentSheetData = [];
        let selectedSSNFields = [];
        let detectedDateFields = [];
        let detectedCostFields = [];
        let policyChangeDate = null;
        let debugMode = false;
        let officeReady = false;
        let worksheetCount = 0;
        let allSheetsData = [];
        let hasSSNInBothSheets = false;
        let selectedSheet1SSN = '';
        let selectedSheet2SSN = '';
        
        // Healthcare abbreviations mapping
        const healthcareAbbreviations = {
            'EE': 'Employee Only',
            'ES': 'Employee + Spouse', 
            'EC': 'Employee + Child(ren)',
            'EF': 'Employee + Family',
            'EES': 'Employee + Eligible Spouse',
            'EEC': 'Employee + Eligible Child(ren)', 
            'EEF': 'Employee + Eligible Family',
            'SP': 'Spouse Only',
            'CH': 'Child Only',
            'FAM': 'Family Coverage',
            'IND': 'Individual Coverage',
            'DEP': 'Dependent Coverage',
            '2P': 'Two Person Coverage',
            '1P': 'One Person Coverage',
            'FTE': 'Full-Time Employee',
            'PTE': 'Part-Time Employee',
            'RET': 'Retiree',
            'COBRA': 'Continuation Coverage',
            'MEC': 'Minimum Essential Coverage',
            'HDHP': 'High Deductible Health Plan',
            'HMO': 'Health Maintenance Organization',
            'PPO': 'Preferred Provider Organization',
            'POS': 'Point of Service',
            'EPO': 'Exclusive Provider Organization',
            'DHMO': 'Dental Health Maintenance Organization',
            'DPPO': 'Dental Preferred Provider Organization',
            'DMO': 'Dental Maintenance Organization',
            'DEN': 'Dental Coverage',
            'VIS': 'Vision Coverage',
            'MH': 'Mental Health Coverage',
            'RX': 'Prescription Drug Coverage',
            'LTC': 'Long-Term Care'
        };

        Office.onReady((info) => {
            console.log('=== OFFICE.JS READY - VERSION 3.2 COMPLETE ===');
            console.log('Host:', info.host);
            console.log('Platform:', info.platform);
            
            officeReady = true;
            updateStepIndicators('none');
            
            const today = new Date();
            document.getElementById('policyDate').value = today.toISOString().split('T')[0];
            
            const urlParams = new URLSearchParams(window.location.search);
            debugMode = urlParams.get('debug') === 'true';
            
            if (debugMode) {
                document.getElementById('debugInfo').style.display = 'block';
                debugLog('Debug mode enabled - Version 3.2 COMPLETE');
            }
            
            setTimeout(setupEventListeners, 100);
        });

        async function checkWorksheetCount() {
            try {
                debugLog('=== CHECKING WORKSHEET COUNT v3.2 ===');
                await Excel.run(async (context) => {
                    const worksheets = context.workbook.worksheets;
                    worksheets.load("count, items/name");
                    await context.sync();
                    
                    worksheetCount = worksheets.count;
                    debugLog(`Detected ${worksheetCount} worksheets`);
                    
                    if (worksheetCount >= 2) {
                        // Load both sheets to check for SSN fields
                        allSheetsData = [];
                        
                        for (let i = 0; i < Math.min(2, worksheets.items.length); i++) {
                            const sheet = worksheets.items[i];
                            const usedRange = sheet.getUsedRange();
                            usedRange.load("values");
                            await context.sync();
                            
                            if (!usedRange.isNullObject && usedRange.values && usedRange.values.length > 0) {
                                const sheetData = {
                                    name: sheet.name,
                                    data: usedRange.values,
                                    headers: usedRange.values[0]
                                };
                                allSheetsData.push(sheetData);
                                debugLog(`  Loaded sheet "${sheet.name}" with ${usedRange.values.length} rows`);
                            }
                        }
                        
                        // Check if both sheets have SSN fields
                        let sheet1HasSSN = false;
                        let sheet2HasSSN = false;
                        
                        if (allSheetsData.length >= 2) {
                            const sheet1Fields = detectFields(allSheetsData[0].headers);
                            const sheet2Fields = detectFields(allSheetsData[1].headers);
                            
                            sheet1HasSSN = sheet1Fields.ssnFields.length > 0;
                            sheet2HasSSN = sheet2Fields.ssnFields.length > 0;
                            
                            debugLog(`  Sheet 1 "${allSheetsData[0].name}" SSN fields: ${sheet1Fields.ssnFields.length}`);
                            debugLog(`  Sheet 2 "${allSheetsData[1].name}" SSN fields: ${sheet2Fields.ssnFields.length}`);
                        }
                        
                        hasSSNInBothSheets = sheet1HasSSN && sheet2HasSSN;
                        debugLog(`SSN fields in both sheets: ${hasSSNInBothSheets}`);
                        
                        if (hasSSNInBothSheets) {
                            createTwoSheetSSNSelections();
                        }
                    } else {
                        hasSSNInBothSheets = false;
                        debugLog('Not enough sheets for Open Enrollment mode');
                    }
                });
            } catch (error) {
                debugLog('Error checking worksheet count: ' + error.message);
                hasSSNInBothSheets = false;
                allSheetsData = [];
            }
        }

        function createTwoSheetSSNSelections() {
            if (allSheetsData.length < 2) return;
            
            const sheet1Data = allSheetsData[0];
            const sheet2Data = allSheetsData[1];
            
            // Update sheet names in the UI
            document.getElementById('sheet1Name').textContent = `${sheet1Data.name} SSN Field:`;
            document.getElementById('sheet2Name').textContent = `${sheet2Data.name} SSN Field:`;
            
            // Create SSN field selections for both sheets
            createSheetSSNCheckboxes('sheet1SSNFields', detectFields(sheet1Data.headers).ssnFields, 'sheet1');
            createSheetSSNCheckboxes('sheet2SSNFields', detectFields(sheet2Data.headers).ssnFields, 'sheet2');
            
            debugLog('Created SSN field selections for both sheets');
        }

        function createSheetSSNCheckboxes(containerId, ssnFields, sheetPrefix) {
            const container = document.getElementById(containerId);
            container.innerHTML = '';
            
            if (ssnFields.length === 0) {
                container.innerHTML = '<div style="color: #6c757d; font-style: italic;">No SSN fields detected</div>';
                return;
            }
            
            ssnFields.forEach((field, index) => {
                const checkboxDiv = document.createElement('div');
                checkboxDiv.className = 'field-checkbox highlighted';
                
                const checkbox = document.createElement('input');
                checkbox.type = 'radio'; // Use radio buttons to ensure only one selection per sheet
                checkbox.name = `${sheetPrefix}_ssn`;
                checkbox.id = `${sheetPrefix}_ssn_${index}`;
                checkbox.value = field.name;
                checkbox.checked = index === 0; // Select first one by default
                checkbox.addEventListener('change', updateTwoSheetSelections);
                
                const label = document.createElement('label');
                label.htmlFor = `${sheetPrefix}_ssn_${index}`;
                label.textContent = field.name;
                
                checkboxDiv.appendChild(checkbox);
                checkboxDiv.appendChild(label);
                container.appendChild(checkboxDiv);
            });
        }

        function updateTwoSheetSelections() {
            // Get selected SSN fields from both sheets
            const sheet1Radio = document.querySelector('input[name="sheet1_ssn"]:checked');
            const sheet2Radio = document.querySelector('input[name="sheet2_ssn"]:checked');
            
            selectedSheet1SSN = sheet1Radio ? sheet1Radio.value : '';
            selectedSheet2SSN = sheet2Radio ? sheet2Radio.value : '';
            
            debugLog(`Selected SSN fields: Sheet1="${selectedSheet1SSN}", Sheet2="${selectedSheet2SSN}"`);
            
            const openEnrollmentBtn = document.getElementById('openEnrollmentBtn');
            
            if (selectedSheet1SSN && selectedSheet2SSN) {
                openEnrollmentBtn.disabled = false;
                showStatus(`Ready for Open Enrollment: ${allSheetsData[0].name}="${selectedSheet1SSN}", ${allSheetsData[1].name}="${selectedSheet2SSN}"`, 'success');
            } else {
                openEnrollmentBtn.disabled = true;
                showStatus('Please select SSN fields from both sheets to continue', 'error');
            }
        }

        function setupEventListeners() {
            const analyzeBtn = document.getElementById('analyzeBtn');
            const processBtn = document.getElementById('processBtn');
            const openEnrollmentBtn = document.getElementById('openEnrollmentBtn');
            
            if (analyzeBtn) {
                analyzeBtn.addEventListener('click', function(event) {
                    event.preventDefault();
                    if (officeReady) analyzeCurrentSheet();
                });
            }
            
            if (processBtn) {
                processBtn.addEventListener('click', function(event) {
                    event.preventDefault();
                    if (officeReady) processEnrollmentData();
                });
            }
            
            if (openEnrollmentBtn) {
                openEnrollmentBtn.addEventListener('click', function(event) {
                    event.preventDefault();
                    if (officeReady) runOpenEnrollmentProcess();
                });
            }
        }

        function debugLog(message) {
            const timestamp = new Date().toLocaleTimeString();
            console.log(`[${timestamp}] ${message}`);
            
            if (debugMode) {
                const debugDiv = document.getElementById('debugInfo');
                if (debugDiv) {
                    debugDiv.innerHTML += `<div>[${timestamp}] ${message}</div>`;
                    debugDiv.scrollTop = debugDiv.scrollHeight;
                }
            }
        }

        function updateStepIndicators(currentStep) {
            const step1 = document.getElementById('step1Indicator');
            const step2 = document.getElementById('step2Indicator');
            
            step1.className = 'step';
            step2.className = 'step';
            
            if (currentStep === 'analyze') {
                step1.className = 'step active';
            } else if (currentStep === 'process') {
                step1.className = 'step completed';
                step2.className = 'step active';
            } else if (currentStep === 'completed') {
                step1.className = 'step completed';
                step2.className = 'step completed';
            }
        }

        function showStatus(message, type = 'info') {
            const statusDiv = document.getElementById('status');
            statusDiv.textContent = message;
            statusDiv.className = `status ${type}`;
            statusDiv.style.display = 'block';
            debugLog(`Status: ${type.toUpperCase()} - ${message}`);
        }

        function updateProgress(percentage) {
            const progressContainer = document.getElementById('progressContainer');
            const progressBar = document.getElementById('progressBar');
            
            if (percentage > 0) {
                progressContainer.style.display = 'block';
                progressBar.style.width = percentage + '%';
            } else {
                progressContainer.style.display = 'none';
            }
        }

        function detectFields(headers) {
            const ssnFields = [];
            const dateFields = [];
            const costFields = [];
            
            headers.forEach((header, index) => {
                if (typeof header === 'string') {
                    const headerLower = header.toLowerCase();
                    
                    if (headerLower.includes('ssn') || 
                        headerLower.includes('social security') ||
                        headerLower.includes('employee ssn')) {
                        ssnFields.push({ name: header, index: index });
                    }
                    
                    if (headerLower.includes('date') || 
                        headerLower.includes('dob') ||
                        headerLower.includes('enrolled') ||
                        headerLower.includes('hire') ||
                        headerLower.includes('start') ||
                        headerLower.includes('effective') ||
                        headerLower.includes('created') ||
                        headerLower.includes('modified')) {
                        dateFields.push({ name: header, index: index });
                    }
                    
                    if (headerLower.includes('cost') || 
                        headerLower.includes('amount') || 
                        headerLower.includes('fee') || 
                        headerLower.includes('price') || 
                        headerLower.includes('premium') || 
                        headerLower.includes('rate') ||
                        headerLower.includes('total') ||
                        headerLower.includes('charge')) {
                        costFields.push({ name: header, index: index });
                    }
                }
            });
            
            return { ssnFields, dateFields, costFields };
        }

        function createSSNFieldCheckboxes(fields) {
            const container = document.getElementById('ssnFieldCheckboxes');
            container.innerHTML = '';
            
            if (fields.length === 0) {
                container.innerHTML = '<div style="color: #6c757d; font-style: italic;">No SSN fields detected</div>';
                return;
            }
            
            fields.forEach((field, index) => {
                const checkboxDiv = document.createElement('div');
                checkboxDiv.className = 'field-checkbox highlighted';
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `ssn_${index}`;
                checkbox.value = field.name;
                checkbox.checked = index === 0;
                checkbox.addEventListener('change', updateSelectedFields);
                
                const label = document.createElement('label');
                label.htmlFor = `ssn_${index}`;
                label.textContent = field.name;
                
                checkboxDiv.appendChild(checkbox);
                checkboxDiv.appendChild(label);
                container.appendChild(checkboxDiv);
            });
        }

        function displayDateFields(fields) {
            const dateFieldsList = document.getElementById('dateFieldsList');
            dateFieldsList.textContent = fields.length > 0 ? fields.map(f => f.name).join(', ') : 'None detected';
        }

        function displayCostFields(fields) {
            const costFieldsList = document.getElementById('costFieldsList');
            costFieldsList.textContent = fields.length > 0 ? fields.map(f => f.name).join(', ') : 'None detected';
        }

        function updateSelectedFields() {
            selectedSSNFields = [];
            
            const ssnCheckboxes = document.querySelectorAll('#ssnFieldCheckboxes input[type="checkbox"]:checked');
            ssnCheckboxes.forEach(checkbox => {
                selectedSSNFields.push(checkbox.value);
            });
            
            const processBtn = document.getElementById('processBtn');
            const openEnrollmentBtn = document.getElementById('openEnrollmentBtn');
            const auditSection = document.getElementById('auditSection');
            
            if (selectedSSNFields.length === 1) {
                if (hasSSNInBothSheets) {
                    // Show Open Enrollment button and configuration section
                    processBtn.style.display = 'none';
                    openEnrollmentBtn.style.display = 'block';
                    auditSection.style.display = 'block';
                    
                    // Check if both sheet SSN fields are selected
                    if (selectedSheet1SSN && selectedSheet2SSN) {
                        openEnrollmentBtn.disabled = false;
                        showStatus(`Ready for Open Enrollment processing`, 'success');
                    } else {
                        openEnrollmentBtn.disabled = true;
                        showStatus('Please select SSN fields from both sheets below', 'info');
                    }
                } else {
                    // Show Process button for single sheet processing
                    processBtn.style.display = 'block';
                    processBtn.disabled = false;
                    openEnrollmentBtn.style.display = 'none';
                    auditSection.style.display = 'none';
                    showStatus(`Ready to process with SSN field: ${selectedSSNFields[0]}`, 'success');
                }
            } else if (selectedSSNFields.length === 0) {
                processBtn.disabled = true;
                openEnrollmentBtn.disabled = true;
                auditSection.style.display = 'none';
                showStatus('Please select exactly one SSN field to continue', 'error');
            } else {
                processBtn.disabled = true;
                openEnrollmentBtn.disabled = true;
                auditSection.style.display = 'none';
                showStatus('Please select only one SSN field. Multiple SSN fields are not supported.', 'error');
            }
        }

        async function analyzeCurrentSheet() {
            try {
                debugLog('=== STARTING ANALYSIS v3.2 ===');
                
                const dateInput = document.getElementById('policyDate');
                if (!dateInput.value) {
                    showStatus('Please select a policy change date first', 'error');
                    return;
                }
                
                policyChangeDate = new Date(dateInput.value);
                debugLog(`Policy change date set to: ${policyChangeDate.toLocaleDateString()}`);
                
                updateStepIndicators('analyze');
                showStatus('Analyzing current sheet and checking for multiple sheets...', 'info');
                updateProgress(10);
                
                // CRITICAL: Check worksheet count and SSN fields FIRST
                await checkWorksheetCount();
                
                updateProgress(25);
                
                await Excel.run(async (context) => {
                    const worksheet = context.workbook.worksheets.getActiveWorksheet();
                    const usedRange = worksheet.getUsedRange();
                    
                    usedRange.load("values");
                    await context.sync();
                    
                    if (usedRange.isNullObject) {
                        showStatus('No data found in the current sheet', 'error');
                        return;
                    }
                    
                    const data = usedRange.values;
                    
                    if (!data || data.length === 0) {
                        showStatus('No data found in the current sheet', 'error');
                        return;
                    }
                    
                    updateProgress(50);
                    
                    currentSheetData = data;
                    detectedHeaders = data[0];
                    debugLog(`Loaded ${data.length} rows with ${detectedHeaders.length} columns from active sheet`);
                    
                    const { ssnFields, dateFields, costFields } = detectFields(detectedHeaders);
                    detectedDateFields = dateFields;
                    detectedCostFields = costFields;
                    
                    updateProgress(75);
                    
                    createSSNFieldCheckboxes(ssnFields);
                    displayDateFields(dateFields);
                    displayCostFields(costFields);
                    
                    document.getElementById('fieldSelection').style.display = 'block';
                    
                    // Update the button display based on multi-sheet detection
                    updateSelectedFields();
                    
                    updateProgress(100);
                    setTimeout(() => updateProgress(0), 1000);
                    
                    debugLog(`=== ANALYSIS COMPLETE v3.2 ===`);
                    debugLog(`Multi-sheet mode: ${hasSSNInBothSheets}`);
                    debugLog(`Sheets available: ${allSheetsData.length}`);
                });
                
            } catch (error) {
                showStatus('Error analyzing sheet: ' + error.message, 'error');
                debugLog('Analysis error: ' + error.message);
                updateProgress(0);
            }
        }

        // Simplified logic based on new requirements
        function shouldIncludeSSN(ssnRows, dateFields, costFields, targetDate, headers) {
            let hasNonZeroCost = false;
            let hasDateInRange = false;
            let hasZeroOrNullCost = false;
            let hasZeroOrNullDate = false;
            
            debugLog(`Evaluating SSN with ${ssnRows.length} rows`);
            
            for (const row of ssnRows) {
                // Check cost fields
                for (const costField of costFields) {
                    const costIndex = headers.indexOf(costField.name);
                    if (costIndex !== -1) {
                        const costValue = row[costIndex];
                        if (isZeroOrNull(costValue)) {
                            hasZeroOrNullCost = true;
                            debugLog(`  Found zero/null cost in ${costField.name}`);
                        } else if (parseFloat(costValue) > 0) {
                            hasNonZeroCost = true;
                        }
                    }
                }
                
                // Check date fields
                for (const dateField of dateFields) {
                    const dateIndex = headers.indexOf(dateField.name);
                    if (dateIndex !== -1) {
                        const dateValue = row[dateIndex];
                        if (isZeroOrNull(dateValue)) {
                            hasZeroOrNullDate = true;
                            debugLog(`  Found zero/null date in ${dateField.name}`);
                        } else if (isDateMatch(dateValue, targetDate)) {
                            hasDateInRange = true;
                            debugLog(`  Found date match in ${dateField.name}`);
                        }
                    }
                }
            }
            
            // EXCLUDE only if: ALL costs > $0 AND NO dates in range AND NO zero/null values
            const shouldExclude = hasNonZeroCost && !hasDateInRange && !hasZeroOrNullCost && !hasZeroOrNullDate;
            const shouldInclude = !shouldExclude;
            
            debugLog(`  Decision: ${shouldInclude ? 'INCLUDE' : 'EXCLUDE'} (nonZeroCost: ${hasNonZeroCost}, dateInRange: ${hasDateInRange}, zeroNullCost: ${hasZeroOrNullCost}, zeroNullDate: ${hasZeroOrNullDate})`);
            
            return shouldInclude;
        }

        function processDataBySSN(data, headers, ssnField, dateFields, costFields, targetDate) {
            const ssnGroups = {};
            const consolidatedRows = [];
            let includedSSNs = 0;
            let excludedSSNs = 0;
            const matchingSSNs = new Set();
            
            const ssnIndex = headers.indexOf(ssnField);
            if (ssnIndex === -1) {
                throw new Error(`SSN field "${ssnField}" not found in headers`);
            }
            
            debugLog(`=== PROCESSING VERSION 3.2 - SIMPLIFIED LOGIC ===`);
            debugLog(`Processing ${data.length - 1} data rows`);
            debugLog(`Target date: ${targetDate.toLocaleDateString()}`);
            
            // Group all rows by SSN first
            for (let i = 1; i < data.length; i++) {
                const row = data[i];
                const ssn = formatSSN(row[ssnIndex]);
                if (!ssn) continue;
                
                if (!ssnGroups[ssn]) {
                    ssnGroups[ssn] = [];
                }
                ssnGroups[ssn].push(row);
            }
            
            debugLog(`Found ${Object.keys(ssnGroups).length} unique SSNs`);
            
            // Apply simplified inclusion logic
            for (const [ssn, rows] of Object.entries(ssnGroups)) {
                if (shouldIncludeSSN(rows, dateFields, costFields, targetDate, headers)) {
                    matchingSSNs.add(ssn);
                    includedSSNs++;
                    
                    const processedRows = rows.map(row => {
                        const processedRow = {};
                        headers.forEach((header, index) => {
                            processedRow[header] = row[index];
                        });
                        return processedRow;
                    });
                    
                    const consolidatedRow = consolidateSSNRows(processedRows, headers);
                    consolidatedRows.push(consolidatedRow);
                } else {
                    excludedSSNs++;
                }
            }
            
            debugLog(`=== FINAL RESULTS ===`);
            debugLog(`Included SSNs: ${includedSSNs}, Excluded SSNs: ${excludedSSNs}`);
            debugLog(`Total consolidated rows: ${consolidatedRows.length}`);
            
            return { 
                ssnGroups: Object.fromEntries(Array.from(matchingSSNs).map(ssn => [ssn, ssnGroups[ssn]])),
                matchingRows: consolidatedRows,
                originalRowCount: Array.from(matchingSSNs).reduce((sum, ssn) => sum + ssnGroups[ssn].length, 0),
                stats: {
                    includedSSNs,
                    excludedSSNs
                }
            };
        }

        // Fuzzy matching function for coverage names
        function fuzzyMatch(str1, str2, threshold = 0.6) {
            if (!str1 || !str2) return false;
            
            const s1 = str1.toLowerCase().trim();
            const s2 = str2.toLowerCase().trim();
            
            // Exact match
            if (s1 === s2) return true;
            
            // Contains match
            if (s1.includes(s2) || s2.includes(s1)) return true;
            
            // Simple Levenshtein distance
            const levenshteinDistance = (a, b) => {
                const matrix = [];
                for (let i = 0; i <= b.length; i++) {
                    matrix[i] = [i];
                }
                for (let j = 0; j <= a.length; j++) {
                    matrix[0][j] = j;
                }
                for (let i = 1; i <= b.length; i++) {
                    for (let j = 1; j <= a.length; j++) {
                        if (b.charAt(i - 1) === a.charAt(j - 1)) {
                            matrix[i][j] = matrix[i - 1][j - 1];
                        } else {
                            matrix[i][j] = Math.min(
                                matrix[i - 1][j - 1] + 1,
                                matrix[i][j - 1] + 1,
                                matrix[i - 1][j] + 1
                            );
                        }
                    }
                }
                return matrix[b.length][a.length];
            };
            
            const distance = levenshteinDistance(s1, s2);
            const maxLength = Math.max(s1.length, s2.length);
            const similarity = 1 - (distance / maxLength);
            
            return similarity >= threshold;
        }

        function expandAbbreviation(abbrev) {
            if (!abbrev) return abbrev;
            
            const upperAbbrev = abbrev.toString().toUpperCase().trim();
            
            // Direct lookup
            if (healthcareAbbreviations[upperAbbrev]) {
                return healthcareAbbreviations[upperAbbrev];
            }
            
            // Check if it contains known abbreviations
            for (const [key, value] of Object.entries(healthcareAbbreviations)) {
                if (upperAbbrev.includes(key)) {
                    return value;
                }
            }
            
            return abbrev; // Return original if no match found
        }

        function findMatchingCoverage(sheet2Value, sheet1Data, headers) {
            if (!sheet2Value) return null;
            
            const expandedValue = expandAbbreviation(sheet2Value);
            debugLog(`Searching for coverage: "${sheet2Value}" (expanded: "${expandedValue}")`);
            
            // Search through all plan/coverage fields in sheet1Data
            for (const header of headers) {
                if (isPlanField(header)) {
                    for (const row of sheet1Data) {
                        const sheet1Value = row[header];
                        if (sheet1Value && typeof sheet1Value === 'string') {
                            // Try fuzzy matching with both original and expanded values
                            if (fuzzyMatch(sheet1Value, sheet2Value) || fuzzyMatch(sheet1Value, expandedValue)) {
                                debugLog(`  Found match: "${sheet1Value}" in ${header}`);
                                return {
                                    field: header,
                                    value: sheet1Value,
                                    matchType: 'fuzzy'
                                };
                            }
                        }
                    }
                }
            }
            
            debugLog(`  No match found for "${sheet2Value}"`);
            return null;
        }

        async function runOpenEnrollmentProcess() {
            try {
                debugLog('=== STARTING OPEN ENROLLMENT PROCESS v3.2 ===');
                showStatus('Running Open Enrollment processing...', 'info');
                updateProgress(10);
                
                if (!hasSSNInBothSheets || allSheetsData.length < 2) {
                    showStatus('Open Enrollment requires 2 sheets with SSN fields', 'error');
                    return;
                }
                
                if (!selectedSheet1SSN || !selectedSheet2SSN) {
                    showStatus('Please select SSN fields from both sheets', 'error');
                    return;
                }
                
                debugLog(`Using selected SSN fields: "${selectedSheet1SSN}" and "${selectedSheet2SSN}"`);
                
                await Excel.run(async (context) => {
                    updateProgress(25);
                    
                    const sheet1Data = allSheetsData[0];
                    const sheet2Data = allSheetsData[1];
                    
                    debugLog(`Processing: ${sheet1Data.name} (${sheet1Data.data.length} rows) and ${sheet2Data.name} (${sheet2Data.data.length} rows)`);
                    
                    updateProgress(50);
                    
                    // Process audit data using the user-selected SSN fields
                    const auditResults = processAuditData(
                        sheet1Data.data, sheet1Data.headers, selectedSheet1SSN,
                        sheet2Data.data, sheet2Data.headers, selectedSheet2SSN
                    );
                    
                    updateProgress(75);
                    
                    // Create Audit Report sheet
                    await createAuditReportSheet(context, auditResults, sheet1Data.headers, sheet2Data.headers);
                    
                    updateProgress(100);
                    showStatus(`Open Enrollment processing completed! Processed ${auditResults.length} SSN records.`, 'success');
                    setTimeout(() => updateProgress(0), 1000);
                });
                
            } catch (error) {
                showStatus('Error running Open Enrollment process: ' + error.message, 'error');
                debugLog('Open Enrollment error: ' + error.message);
                updateProgress(0);
            }
        }

        function processAuditData(sheet1Data, sheet1Headers, sheet1SSNField, sheet2Data, sheet2Headers, sheet2SSNField) {
            const auditResults = [];
            const sheet1SSNIndex = sheet1Headers.indexOf(sheet1SSNField);
            const sheet2SSNIndex = sheet2Headers.indexOf(sheet2SSNField);
            
            debugLog('=== PROCESSING AUDIT DATA ===');
            
            // Group Sheet 1 data by SSN
            const sheet1BySSN = {};
            for (let i = 1; i < sheet1Data.length; i++) {
                const row = sheet1Data[i];
                const ssn = formatSSN(row[sheet1SSNIndex]);
                if (ssn) {
                    if (!sheet1BySSN[ssn]) sheet1BySSN[ssn] = [];
                    const rowObj = {};
                    sheet1Headers.forEach((header, index) => {
                        rowObj[header] = row[index];
                    });
                    sheet1BySSN[ssn].push(rowObj);
                }
            }
            
            // Process Sheet 2 changes and match with Sheet 1
            for (let i = 1; i < sheet2Data.length; i++) {
                const row = sheet2Data[i];
                const ssn = formatSSN(row[sheet2SSNIndex]);
                if (!ssn) continue;
                
                debugLog(`Processing audit for SSN: ${ssn}`);
                
                const sheet1Rows = sheet1BySSN[ssn] || [];
                if (sheet1Rows.length === 0) {
                    debugLog(`  No matching data in Sheet 1 for SSN ${ssn}`);
                    continue;
                }
                
                // Create audit record
                const auditRecord = { _ssn: ssn };
                
                // Copy basic info from Sheet 1 (consolidated)
                const consolidatedSheet1 = consolidateSSNRows(sheet1Rows, sheet1Headers);
                Object.keys(consolidatedSheet1).forEach(key => {
                    if (!key.startsWith('_') && !isPlanField(key) && !isCostField(key)) {
                        auditRecord[key] = consolidatedSheet1[key];
                    }
                });
                
                // Process coverage changes from Sheet 2
                sheet2Headers.forEach((header, index) => {
                    const sheet2Value = row[index];
                    if (sheet2Value && header !== sheet2SSNField && !isDateField(header)) {
                        // Try to find matching coverage in Sheet 1
                        const match = findMatchingCoverage(sheet2Value, sheet1Rows, sheet1Headers);
                        
                        if (match) {
                            // Find cost for this coverage
                            let oldCost = 0;
                            let newCost = 0;
                            
                            // Get cost from Sheet 1
                            for (const s1Row of sheet1Rows) {
                                if (s1Row[match.field] === match.value) {
                                    for (const costField of detectFields(sheet1Headers).costFields) {
                                        const cost = parseFloat(s1Row[costField.name]) || 0;
                                        if (cost > 0) {
                                            oldCost += cost;
                                        }
                                    }
                                }
                            }
                            
                            // Get cost from Sheet 2 (look for cost fields in same row)
                            for (const costField of detectFields(sheet2Headers).costFields) {
                                const cost = parseFloat(row[sheet2Headers.indexOf(costField.name)]) || 0;
                                if (cost > 0) {
                                    newCost += cost;
                                }
                            }
                            
                            const expandedNewValue = expandAbbreviation(sheet2Value);
                            auditRecord[`${header}_AUDIT`] = `OLD: ${match.value} / NEW: ${expandedNewValue} : Cost : ${newCost.toFixed(2)}`;
                            
                        } else {
                            // No match found - this is a new coverage
                            const expandedValue = expandAbbreviation(sheet2Value);
                            auditRecord[`${header}_AUDIT`] = `NEW: ${expandedValue} : Cost : $0.00`;
                        }
                    }
                });
                
                auditResults.push(auditRecord);
            }
            
            debugLog(`Generated ${auditResults.length} audit records`);
            return auditResults;
        }

        async function createAuditReportSheet(context, auditResults, sheet1Headers, sheet2Headers) {
            try {
                debugLog('Creating Audit Report sheet...');
                
                // Delete existing sheet if it exists
                try {
                    const existingSheet = context.workbook.worksheets.getItem("Audit Report");
                    existingSheet.delete();
                    await context.sync();
                } catch (e) {
                    // Sheet doesn't exist, continue
                }
                
                const auditSheet = context.workbook.worksheets.add("Audit Report");
                await context.sync();
                
                if (auditResults.length === 0) {
                    const noDataRange = auditSheet.getRange("A1");
                    noDataRange.values = [["No audit data to display"]];
                    return;
                }
                
                // Create headers from first audit record
                const sampleRecord = auditResults[0];
                const auditHeaders = Object.keys(sampleRecord).filter(key => !key.startsWith('_'));
                
                // Write headers
                const headerRange = auditSheet.getRange(`A1:${getExcelColumnName(auditHeaders.length)}1`);
                headerRange.values = [auditHeaders];
                headerRange.format.font.bold = true;
                headerRange.format.fill.color = "#dc3545";
                headerRange.format.font.color = "white";
                await context.sync();
                
                // Write data
                let currentRow = 2;
                for (const record of auditResults) {
                    const rowData = auditHeaders.map(header => {
                        let value = record[header];
                        if (value === undefined || value === null) return '';
                        
                        if (isDateField(header) && value !== '') {
                            return formatDateForExcel(value);
                        }
                        
                        return value;
                    });
                    
                    const rowRange = auditSheet.getRange(`A${currentRow}:${getExcelColumnName(auditHeaders.length)}${currentRow}`);
                    rowRange.values = [rowData];
                    
                    // Highlight audit columns
                    auditHeaders.forEach((header, index) => {
                        if (header.includes('_AUDIT')) {
                            const cellRange = auditSheet.getRange(`${getExcelColumnName(index + 1)}${currentRow}`);
                            cellRange.format.fill.color = "#fff3cd";
                            cellRange.format.font.bold = true;
                        }
                    });
                    
                    currentRow++;
                    
                    if (currentRow % 25 === 0) {
                        await context.sync();
                    }
                }
                
                await context.sync();
                
                // Auto-fit columns
                auditSheet.getUsedRange().format.autofitColumns();
                await context.sync();
                
                // Add summary
                const summaryRow = currentRow + 2;
                const summaryData = [
                    ['AUDIT SUMMARY', ''],
                    ['Total SSNs Processed', auditResults.length],
                    ['Report Generated', new Date().toLocaleString()]
                ];
                
                for (let i = 0; i < summaryData.length; i++) {
                    const summaryRange = auditSheet.getRange(`A${summaryRow + i}:B${summaryRow + i}`);
                    summaryRange.values = [summaryData[i]];
                    if (i === 0) {
                        summaryRange.format.font.bold = true;
                        summaryRange.format.fill.color = "#28a745";
                        summaryRange.format.font.color = "white";
                    }
                }
                
                await context.sync();
                auditSheet.activate();
                await context.sync();
                
                debugLog('Audit Report sheet created successfully');
                
            } catch (error) {
                debugLog('Error creating Audit Report sheet: ' + error.message);
                throw error;
            }
        }

        // Utility functions (keeping existing ones)
        function parseExcelDate(value) {
            if (!value) return null;
            
            if (value instanceof Date) {
                return value;
            }
            
            if (typeof value === 'number' && value > 0) {
                let jsDate;
                
                if (value > 25569) {
                    jsDate = new Date((value - 25569) * 86400 * 1000);
                } else {
                    const excelEpoch = new Date(1900, 0, 1);
                    jsDate = new Date(excelEpoch.getTime() + (value - 1) * 24 * 60 * 60 * 1000);
                    
                    if (value >= 60) {
                        jsDate.setTime(jsDate.getTime() - 24 * 60 * 60 * 1000);
                    }
                }
                
                return jsDate;
            }
            
            if (typeof value === 'string') {
                const cleanStr = value.trim();
                if (cleanStr === '') return null;
                
                const parsed = new Date(cleanStr);
                if (!isNaN(parsed.getTime())) {
                    return parsed;
                }
                
                const dateFormats = [
                    { regex: /^(\d{1,2})\/(\d{1,2})\/(\d{4})$/, order: 'MDY' },
                    { regex: /^(\d{4})-(\d{1,2})-(\d{1,2})$/, order: 'YMD' },
                    { regex: /^(\d{1,2})-(\d{1,2})-(\d{4})$/, order: 'MDY' },
                    { regex: /^(\d{1,2})\/(\d{1,2})\/(\d{2})$/, order: 'MDY2' },
                ];
                
                for (const format of dateFormats) {
                    const match = cleanStr.match(format.regex);
                    if (match) {
                        let year, month, day;
                        
                        if (format.order === 'YMD') {
                            [, year, month, day] = match;
                        } else if (format.order === 'MDY') {
                            [, month, day, year] = match;
                        } else if (format.order === 'MDY2') {
                            [, month, day, year] = match;
                            const yr = parseInt(year);
                            year = yr < 50 ? 2000 + yr : 1900 + yr;
                        }
                        
                        const date = new Date(parseInt(year), parseInt(month) - 1, parseInt(day));
                        if (!isNaN(date.getTime())) {
                            return date;
                        }
                    }
                }
            }
            
            return null;
        }

        function formatDateForExcel(value) {
            if (!value) return '';
            
            const date = parseExcelDate(value);
            if (!date || isNaN(date.getTime())) {
                return value;
            }
            
            const excelEpoch = new Date(1900, 0, 1);
            let serialDate = Math.floor((date.getTime() - excelEpoch.getTime()) / (24 * 60 * 60 * 1000)) + 1;
            
            if (serialDate >= 60) {
                serialDate += 1;
            }
            
            return serialDate;
        }

        function isDateMatch(dateValue, targetDate) {
            if (!dateValue || !targetDate) return false;
            
            const parsedDate = parseExcelDate(dateValue);
            if (!parsedDate || isNaN(parsedDate.getTime())) {
                return false;
            }
            
            return parsedDate.toDateString() === targetDate.toDateString();
        }

        function isZeroOrNull(value) {
            return value === null || 
                   value === undefined || 
                   value === '' || 
                   value === 0 || 
                   (typeof value === 'string' && value.trim() === '') ||
                   (typeof value === 'string' && value.trim() === '0');
        }

        function formatSSN(ssn) {
            if (!ssn) return '';
            
            let ssnStr = ssn.toString().replace(/\D/g, '');
            
            if (ssnStr.length === 9) {
                return ssnStr.substring(0, 3) + '-' + ssnStr.substring(3, 5) + '-' + ssnStr.substring(5);
            }
            
            return ssn.toString();
        }

        function isDollarValue(value) {
            if (typeof value !== 'number') {
                if (typeof value === 'string') {
                    const cleanValue = value.replace(/[$,]/g, '');
                    const parsed = parseFloat(cleanValue);
                    if (!isNaN(parsed)) {
                        value = parsed;
                    } else {
                        return false;
                    }
                } else {
                    return false;
                }
            }
            return value > 0 && value < 10000;
        }

        function isPlanField(header) {
            const headerLower = header.toLowerCase();
            
            const excludeKeywords = ['employee', 'member', 'user', 'person', 'first', 'last', 'full', 
                                   'address', 'street', 'city', 'state', 'zip', 'phone', 'email', 
                                   'ssn', 'social', 'id', 'number', 'birth', 'age', 'gender',
                                   'department', 'title', 'position', 'hire', 'start', 'end',
                                   'salary', 'wage', 'payroll', 'tax'];
            
            for (const exclude of excludeKeywords) {
                if (headerLower.includes(exclude)) {
                    return false;
                }
            }
            
            const planKeywords = ['plan', 'coverage', 'benefit', 'option', 'type', 'product', 
                                'insurance', 'medical', 'dental', 'vision', 'life', 'disability',
                                'health', 'wellness', 'prescription', 'drug', 'pharmacy'];
            
            for (const keyword of planKeywords) {
                if (headerLower.includes(keyword)) {
                    return true;
                }
            }
            
            return false;
        }

        function isCostField(header) {
            const headerLower = header.toLowerCase();
            return headerLower.includes('cost') || headerLower.includes('amount') || 
                   headerLower.includes('fee') || headerLower.includes('price') || 
                   headerLower.includes('premium') || headerLower.includes('rate');
        }

        function isDateField(header) {
            const headerLower = header.toLowerCase();
            return headerLower.includes('date') || 
                   headerLower.includes('dob') ||
                   headerLower.includes('enrolled') ||
                   headerLower.includes('hire') ||
                   headerLower.includes('start') ||
                   headerLower.includes('effective') ||
                   headerLower.includes('created') ||
                   headerLower.includes('modified');
        }

        function consolidateSSNRows(rows, headers) {
            if (rows.length === 0) return {};
            if (rows.length === 1) return rows[0];
            
            const consolidatedRow = {};
            let totalDollarAmount = 0;
            
            const costFields = headers.filter(header => isCostField(header));
            const planFields = headers.filter(header => isPlanField(header));
            
            headers.forEach(header => {
                const values = rows.map(row => row[header]).filter(val => val !== null && val !== undefined && val !== '');
                
                if (values.length === 0) {
                    consolidatedRow[header] = '';
                    return;
                }
                
                if (isDateField(header)) {
                    const validDates = values.filter(val => {
                        const parsed = parseExcelDate(val);
                        return parsed && !isNaN(parsed.getTime());
                    });
                    
                    consolidatedRow[header] = validDates.length > 0 ? validDates[0] : values[0];
                    return;
                }
                
                const dollarValues = values.filter(val => isDollarValue(val));
                if (dollarValues.length > 0 && costFields.includes(header)) {
                    const sum = dollarValues.reduce((acc, val) => acc + parseFloat(val), 0);
                    totalDollarAmount += sum;
                    consolidatedRow[header] = sum;
                } else if (planFields.includes(header)) {
                    const planCostPairs = [];
                    
                    rows.forEach(row => {
                        const planName = row[header];
                        if (planName && planName !== '') {
                            let correspondingCost = null;
                            
                            for (const costField of costFields) {
                                const costValue = row[costField];
                                if (costValue && isDollarValue(costValue)) {
                                    correspondingCost = parseFloat(costValue);
                                    break;
                                }
                            }
                            
                            if (correspondingCost !== null) {
                                planCostPairs.push(`${planName} (${correspondingCost.toFixed(2)})`);
                            } else {
                                planCostPairs.push(String(planName));
                            }
                        }
                    });
                    
                    const uniquePlanCostPairs = [...new Set(planCostPairs)];
                    consolidatedRow[header] = uniquePlanCostPairs.join(' | ');
                    
                } else {
                    const uniqueValues = [...new Set(values.map(val => String(val)))];
                    
                    if (uniqueValues.length === 1) {
                        consolidatedRow[header] = values[0];
                    } else {
                        consolidatedRow[header] = uniqueValues.join(' | ');
                    }
                }
            });
            
            consolidatedRow._isConsolidated = true;
            consolidatedRow._originalRowCount = rows.length;
            consolidatedRow._totalDollarAmount = totalDollarAmount;
            
            return consolidatedRow;
        }

        async function processEnrollmentData() {
            try {
                debugLog('Starting processEnrollmentData function...');
                
                updateStepIndicators('process');
                showStatus('Processing enrollment data...', 'info');
                updateProgress(10);
                
                if (currentSheetData.length === 0) {
                    showStatus('No data to process. Please run Step 1: Analyze first.', 'error');
                    return;
                }
                
                if (selectedSSNFields.length !== 1) {
                    showStatus('Please select exactly one SSN field.', 'error');
                    return;
                }
                
                if (!policyChangeDate) {
                    showStatus('Please select a policy change date.', 'error');
                    return;
                }
                
                await Excel.run(async (context) => {
                    updateProgress(25);
                    
                    const processedData = processDataBySSN(
                        currentSheetData, 
                        detectedHeaders, 
                        selectedSSNFields[0], 
                        detectedDateFields,
                        detectedCostFields,
                        policyChangeDate
                    );
                    
                    updateProgress(50);
                    
                    await createPolicyChangesSheetWithRetry(context, processedData.ssnGroups, detectedHeaders);
                    
                    updateProgress(75);
                    
                    await createSummarySheet(context, processedData, selectedSSNFields[0], detectedDateFields, detectedCostFields);
                    
                    updateProgress(90);
                    
                    updateStepIndicators('completed');
                    showStatus(`Processing complete! Found ${processedData.matchingRows.length} matching records.`, 'success');
                    
                    updateProgress(100);
                    setTimeout(() => updateProgress(0), 1000);
                });
            } catch (error) {
                showStatus('Error processing data: ' + error.message, 'error');
                debugLog('Processing error: ' + error.message);
                updateProgress(0);
            }
        }

        // Keep existing utility functions for sheet creation
        async function createPolicyChangesSheetWithRetry(context, ssnGroups, originalHeaders, maxRetries = 3) {
            for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                    await createPolicyChangesSheet(context, ssnGroups, originalHeaders);
                    return;
                } catch (error) {
                    if (attempt === maxRetries) {
                        throw new Error(`Failed to create Policy Changes sheet after ${maxRetries} attempts: ${error.message}`);
                    }
                    
                    const delay = Math.pow(2, attempt - 1) * 1000;
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
        }

        async function createPolicyChangesSheet(context, ssnGroups, originalHeaders) {
            try {
                const worksheets = context.workbook.worksheets;
                const sheetName = "Policy Changes to Note";
                
                try {
                    const existingSheet = worksheets.getItem(sheetName);
                    existingSheet.delete();
                    await context.sync();
                } catch (deleteError) {
                    // Sheet doesn't exist
                }
                
                const newSheet = worksheets.add(sheetName);
                await context.sync();
                
                if (Object.keys(ssnGroups).length === 0) {
                    const noDataRange = newSheet.getRange("A1");
                    noDataRange.values = [["No policy changes found matching the simplified criteria"]];
                    noDataRange.format.font.bold = true;
                    await context.sync();
                    return;
                }
                
                const enhancedHeaders = [...originalHeaders];
                enhancedHeaders.push('CONSOLIDATED_ROWS');
                enhancedHeaders.push('TOTAL_DOLLAR_AMOUNT');
                enhancedHeaders.push('CONSOLIDATION_NOTES');
                
                const headerRange = newSheet.getRange(`A1:${getExcelColumnName(enhancedHeaders.length)}1`);
                headerRange.values = [enhancedHeaders];
                headerRange.format.font.bold = true;
                headerRange.format.fill.color = "#0078d4";
                headerRange.format.font.color = "white";
                await context.sync();
                
                let currentRow = 2;
                
                for (const [ssn, rows] of Object.entries(ssnGroups)) {
                    const processedRows = rows.map(row => {
                        const processedRow = {};
                        originalHeaders.forEach((header, index) => {
                            processedRow[header] = row[index];
                        });
                        return processedRow;
                    });
                    
                    const consolidatedRow = consolidateSSNRows(processedRows, originalHeaders);
                    
                    const rowData = originalHeaders.map(header => {
                        let value = consolidatedRow[header];
                        if (value === undefined || value === null) {
                            return '';
                        }
                        
                        if (isDateField(header) && value !== '') {
                            const excelDate = formatDateForExcel(value);
                            return excelDate !== '' ? excelDate : value;
                        }
                        
                        return value;
                    });
                    
                    rowData.push(consolidatedRow._originalRowCount || 1);
                    rowData.push(consolidatedRow._totalDollarAmount || 0);
                    
                    let notes = '';
                    if (consolidatedRow._originalRowCount > 1) {
                        notes = `Consolidated ${consolidatedRow._originalRowCount} rows using simplified v3.0 logic. `;
                        notes += 'Plan/coverage fields show individual plan costs as "Plan Name ($Cost)".';
                    } else {
                        notes = 'Single row - no consolidation needed';
                    }
                    rowData.push(notes);
                    
                    const rowRange = newSheet.getRange(`A${currentRow}:${getExcelColumnName(enhancedHeaders.length)}${currentRow}`);
                    rowRange.values = [rowData];
                    
                    // Format date fields
                    originalHeaders.forEach((header, headerIndex) => {
                        if (isDateField(header)) {
                            const cellRange = newSheet.getRange(`${getExcelColumnName(headerIndex + 1)}${currentRow}`);
                            cellRange.numberFormat = [["mm/dd/yyyy"]];
                        }
                    });
                    
                    // Format dollar amount column
                    const dollarAmountColIndex = enhancedHeaders.length - 1;
                    const dollarRange = newSheet.getRange(`${getExcelColumnName(dollarAmountColIndex)}${currentRow}`);
                    dollarRange.numberFormat = [["$#,##0.00"]];
                    
                    if (consolidatedRow._originalRowCount > 1) {
                        rowRange.format.fill.color = "#E3F2FD";
                        dollarRange.format.font.bold = true;
                        dollarRange.format.fill.color = "#FFEB3B";
                    }
                    
                    currentRow++;
                    
                    if (currentRow % 25 === 0) {
                        await context.sync();
                    }
                }
                
                await context.sync();
                
                try {
                    newSheet.getUsedRange().format.autofitColumns();
                    await context.sync();
                } catch (autofitError) {
                    debugLog('Auto-fit failed: ' + autofitError.message);
                }
                
                // Add summary
                const summaryStartRow = currentRow + 2;
                const summaryData = [
                    ['PROCESSING SUMMARY v3.2', ''],
                    ['Total Unique SSNs:', Object.keys(ssnGroups).length],
                    ['Total Original Rows:', Object.values(ssnGroups).reduce((sum, rows) => sum + rows.length, 0)],
                    ['Total Consolidated Rows:', Object.keys(ssnGroups).length],
                    ['Logic Version:', 'Simplified v3.2 - SSN field selection + multi-sheet processing'],
                    ['Processing Date:', new Date().toLocaleDateString()],
                    ['Processing Time:', new Date().toLocaleTimeString()]
                ];
                
                for (let i = 0; i < summaryData.length; i++) {
                    const summaryRange = newSheet.getRange(`A${summaryStartRow + i}:B${summaryStartRow + i}`);
                    summaryRange.values = [summaryData[i]];
                    
                    if (i === 0) {
                        summaryRange.format.font.bold = true;
                        summaryRange.format.fill.color = "#4CAF50";
                        summaryRange.format.font.color = "white";
                    }
                }
                
                await context.sync();
                newSheet.activate();
                await context.sync();
                
            } catch (error) {
                debugLog('Policy changes sheet creation failed: ' + error.message);
                throw error;
            }
        }

        async function createSummarySheet(context, processedData, ssnField, dateFields, costFields) {
            try {
                debugLog('Starting summary sheet creation...');
                
                const existingSheet = context.workbook.worksheets.getItemOrNullObject("Processing Summary");
                await context.sync();
                
                if (!existingSheet.isNullObject) {
                    existingSheet.delete();
                    await context.sync();
                }
                
                const summarySheet = context.workbook.worksheets.add("Processing Summary");
                await context.sync();
                
                const totalOriginalRows = processedData.originalRowCount || 0;
                const totalConsolidatedRows = processedData.matchingRows.length;
                const totalSSNs = Object.keys(processedData.ssnGroups).length;
                
                let totalDollarAmount = 0;
                let consolidatedRowsCount = 0;
                
                processedData.matchingRows.forEach(row => {
                    if (row._totalDollarAmount) {
                        totalDollarAmount += row._totalDollarAmount;
                    }
                    if (row._originalRowCount > 1) {
                        consolidatedRowsCount++;
                    }
                });
                
                const summaryData = [
                    ["Enrollment Data Processing Summary v3.2", ""],
                    ["", ""],
                    ["BASIC INFORMATION", ""],
                    ["Policy Change Date", policyChangeDate.toLocaleDateString()],
                    ["Selected SSN Field", ssnField],
                    ["Date Fields Scanned", dateFields.map(f => f.name).join(", ")],
                    ["Cost Fields Scanned", costFields.map(f => f.name).join(", ")],
                    ["", ""],
                    ["DATA PROCESSING RESULTS", ""],
                    ["Total Original Rows Found", totalOriginalRows],
                    ["Total Consolidated Rows Created", totalConsolidatedRows],
                    ["Unique SSNs Processed", totalSSNs],
                    ["SSNs Included", processedData.stats?.includedSSNs || 0],
                    ["SSNs Excluded", processedData.stats?.excludedSSNs || 0],
                    ["SSNs with Multiple Rows", consolidatedRowsCount],
                    ["SSNs with Single Row", totalSSNs - consolidatedRowsCount],
                    ["", ""],
                    ["FINANCIAL SUMMARY", ""],
                    ["Total Dollar Amount", totalDollarAmount],
                    ["Average per SSN", totalSSNs > 0 ? (totalDollarAmount / totalSSNs) : 0],
                    ["", ""],
                    ["SIMPLIFIED LOGIC v3.2", ""],
                    ["Rule 1", "EXCLUDE: SSNs where ALL rows have cost > $0 AND ALL date fields NOT in target range"],
                    ["Rule 2", "INCLUDE: All other SSN combinations (ANY date match OR ANY zero/null values)"],
                    ["Rule 3", "All rows for included SSNs are consolidated into single row"],
                    ["Rule 4", "Dollar amounts summed across all rows per SSN"],
                    ["Rule 5", "Plan/coverage fields combine as 'Plan Name ($Cost)' format"],
                    ["Rule 6", "Date fields maintain proper Excel date formatting"],
                    ["", ""],
                    ["PROCESSING METADATA", ""],
                    ["Processing Date", new Date().toLocaleDateString()],
                    ["Processing Time", new Date().toLocaleTimeString()],
                    ["Debug Mode", debugMode ? "Enabled" : "Disabled"],
                    ["Version", "3.2 COMPLETE - SSN Field Selection for Multi-Sheet Processing"]
                ];
                
                for (let i = 0; i < summaryData.length; i++) {
                    const rowRange = summarySheet.getRange(`A${i + 1}:B${i + 1}`);
                    rowRange.values = [summaryData[i]];
                    
                    const content = summaryData[i][0];
                    if (content.includes("Processing Summary")) {
                        rowRange.merge();
                        rowRange.format.font.bold = true;
                        rowRange.format.font.size = 14;
                        rowRange.format.fill.color = "#0078d4";
                        rowRange.format.font.color = "white";
                        rowRange.format.horizontalAlignment = "Center";
                    } else if (content.includes("INFORMATION") || content.includes("RESULTS") || content.includes("SUMMARY") || content.includes("LOGIC") || content.includes("METADATA")) {
                        rowRange.format.font.bold = true;
                        rowRange.format.fill.color = "#E3F2FD";
                        rowRange.format.font.color = "#1976D2";
                    } else if (content.startsWith("Rule")) {
                        rowRange.format.fill.color = "#F3E5F5";
                        rowRange.format.font.color = "#7B1FA2";
                    }
                }
                
                // Format dollar amount cells
                const dollarRows = [19, 20];
                dollarRows.forEach(rowNum => {
                    if (rowNum <= summaryData.length) {
                        const cellRange = summarySheet.getRange(`B${rowNum}`);
                        cellRange.numberFormat = [["$#,##0.00"]];
                    }
                });
                
                await context.sync();
                summarySheet.getUsedRange().format.autofitColumns();
                await context.sync();
                
            } catch (error) {
                debugLog('Summary sheet creation failed: ' + error.message);
                throw error;
            }
        }

        function getExcelColumnName(columnNumber) {
            let columnName = '';
            while (columnNumber > 0) {
                const remainder = (columnNumber - 1) % 26;
                columnName = String.fromCharCode(65 + remainder) + columnName;
                columnNumber = Math.floor((columnNumber - 1) / 26);
            }
            return columnName;
        }

        // Add keyboard shortcuts
        document.addEventListener('keydown', (event) => {
            if (event.ctrlKey && event.altKey && event.key === '1') {
                event.preventDefault();
                if (officeReady) analyzeCurrentSheet();
            }
            
            if (event.ctrlKey && event.altKey && event.key === '2') {
                event.preventDefault();
                if (officeReady && selectedSSNFields.length === 1) processEnrollmentData();
            }
            
            if (event.ctrlKey && event.altKey && event.key === '3') {
                event.preventDefault();
                if (officeReady && hasSSNInBothSheets) runOpenEnrollmentProcess();
            }
        });

        console.log('=== SCRIPT LOADED COMPLETELY - VERSION 3.2 COMPLETE ===');
        console.log('New Features in v3.2:');
        console.log('- Fixed multi-sheet detection during Step 1: Analyze');
        console.log('- User can select specific SSN fields from each sheet (radio buttons)');
        console.log('- Shows sheet names and field names clearly in UI');
        console.log('- Open Enrollment button only appears when both sheets have SSN fields');
        console.log('- Enhanced debugging and status messages');
        console.log('- Healthcare abbreviation expansion (EE, ES, PPO, HMO, etc.)');
        console.log('- Fuzzy matching for coverage names between sheets');
        console.log('- Simplified inclusion logic: Exclude only if ALL costs > $0 AND ALL dates NOT in range');
        console.log('- Keyboard shortcuts: Ctrl+Alt+1 (analyze), Ctrl+Alt+2 (process), Ctrl+Alt+3 (open enrollment)');
        console.log('=== READY FOR USE ===');
    </script>
</body>
</html>