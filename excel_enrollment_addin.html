<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enrollment Data Processor v3.7 CONCEPT CHANGE</title>
    <script src="https://appsforoffice.microsoft.com/lib/1/hosted/office.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        
        .container {
            max-width: 400px;
            margin: 0 auto;
            background: white;
            padding: 25px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .logo {
            text-align: center;
            margin-bottom: 20px;
            font-weight: bold;
            font-size: 28px;
            letter-spacing: 2px;
        }
        
        .logo-united {
            color: #0078d4;
        }
        
        .logo-enroll {
            color: #106ebe;
        }
        
        h1 {
            color: #0078d4;
            text-align: center;
            margin-bottom: 30px;
            font-size: 20px;
        }
        
        .date-input-section {
            margin-bottom: 25px;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 4px;
            border-left: 4px solid #0078d4;
        }
        
        .date-input-section label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #495057;
        }
        
        .date-input-section input[type="date"] {
            width: 100%;
            padding: 8px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-size: 14px;
        }
        
        .date-input-section .help-text {
            margin-top: 5px;
            font-size: 12px;
            color: #6c757d;
        }
        
        .button {
            background-color: #0078d4;
            color: white;
            border: none;
            padding: 12px 24px;
            font-size: 16px;
            border-radius: 4px;
            cursor: pointer;
            width: 100%;
            margin: 10px 0;
            transition: background-color 0.3s;
        }
        
        .button:hover {
            background-color: #106ebe;
        }
        
        .button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        
        .button.step1 {
            background-color: #28a745;
        }
        
        .button.step1:hover {
            background-color: #218838;
        }
        
        .button.step2 {
            background-color: #0078d4;
        }
        
        .button.step2:hover {
            background-color: #106ebe;
        }
        
        .button.open-enrollment {
            background-color: #28a745;
        }
        
        .button.open-enrollment:hover {
            background-color: #218838;
        }
        
        .status {
            margin-top: 20px;
            padding: 15px;
            border-radius: 4px;
            font-size: 14px;
            line-height: 1.5;
        }
        
        .status.success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .status.error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        
        .status.info {
            background-color: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        
        .field-selection {
            margin: 15px 0;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 4px;
            font-size: 14px;
            display: none;
        }
        
        .field-group {
            margin-bottom: 20px;
        }
        
        .field-group h3 {
            margin: 0 0 10px 0;
            color: #495057;
            font-size: 16px;
        }
        
        .field-checkbox {
            margin: 8px 0;
            display: flex;
            align-items: center;
        }
        
        .field-checkbox input[type="checkbox"] {
            margin-right: 8px;
            transform: scale(1.2);
        }
        
        .field-checkbox label {
            cursor: pointer;
            user-select: none;
            color: #495057;
        }
        
        .field-checkbox.highlighted {
            background-color: #fff3cd;
            padding: 5px;
            border-radius: 4px;
            border-left: 4px solid #ffc107;
        }
        
        .field-checkbox.data-detected {
            background-color: #d4edda;
            border-left: 4px solid #28a745;
        }
        
        .progress {
            width: 100%;
            height: 20px;
            background-color: #e9ecef;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }
        
        .progress-bar {
            height: 100%;
            background-color: #0078d4;
            width: 0%;
            transition: width 0.3s;
        }
        
        .step-indicator {
            text-align: center;
            margin-bottom: 20px;
            font-size: 14px;
            color: #6c757d;
        }
        
        .step {
            display: inline-block;
            padding: 5px 10px;
            margin: 0 5px;
            border-radius: 15px;
            background-color: #e9ecef;
        }
        
        .step.active {
            background-color: #0078d4;
            color: white;
        }
        
        .step.completed {
            background-color: #28a745;
            color: white;
        }
        
        .date-info {
            margin: 10px 0;
            padding: 10px;
            background-color: #e3f2fd;
            border-radius: 4px;
            font-size: 12px;
        }
        
        .zero-null-info {
            margin: 10px 0;
            padding: 10px;
            background-color: #fff3cd;
            border-radius: 4px;
            font-size: 12px;
            border-left: 4px solid #ffc107;
        }
        
        .debug-info {
            margin: 10px 0;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 4px;
            font-size: 11px;
            color: #6c757d;
            border: 1px solid #dee2e6;
        }
        
        .audit-section {
            margin: 15px 0;
            padding: 15px;
            background-color: #f8d7da;
            border-radius: 4px;
            border-left: 4px solid #dc3545;
            display: none;
        }
        
        .sheet-selection {
            margin: 10px 0;
        }
        
        .sheet-selection h4 {
            margin: 0 0 10px 0;
            color: #495057;
            font-size: 14px;
        }

        .open-enrollment-info {
            margin: 10px 0;
            padding: 10px;
            background-color: #d4edda;
            border-radius: 4px;
            font-size: 12px;
            border-left: 4px solid #28a745;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="logo">
            <span class="logo-united">UNITED</span>
            <span class="logo-enroll">ENROLL</span>
        </div>
        <h1>Enrollment Data Processor v3.7</h1>
        
        <div class="date-input-section">
            <label for="policyDate">Policy Change Date:</label>
            <input type="date" id="policyDate" required>
            <div class="help-text">Select the specific date when policy changes occurred</div>
        </div>
        
        <div class="step-indicator">
            <span class="step" id="step1Indicator">1</span>
            <span class="step" id="step2Indicator">2</span>
        </div>
        
        <button class="button step1" id="analyzeBtn" type="button">
            Step 1: Analyze
        </button>
        
        <div id="fieldSelection" class="field-selection">
            <div class="field-group">
                <h3>SSN Fields Found:</h3>
                <div id="ssnFieldCheckboxes"></div>
                <div class="date-info">
                    <strong>Note:</strong> Only one SSN field should be selected. Green highlighting indicates data-based detection.
                </div>
            </div>
            
            <div id="dateFieldsInfo" class="date-info">
                <strong>Date Fields Detected:</strong> <span id="dateFieldsList"></span><br>
                <em>All date fields will be checked for the specified policy date.</em>
            </div>
            
            <div id="costFieldsInfo" class="date-info">
                <strong>Cost Fields Detected:</strong> <span id="costFieldsList"></span><br>
                <em>Cost fields will be checked for values greater than $0.</em>
            </div>
            
            <div class="zero-null-info">
                <strong>Enhanced Logic v3.7:</strong> 
                <ul style="margin: 5px 0; padding-left: 20px;">
                    <li><strong>Single Sheet:</strong> EXCLUDE SSNs where ALL rows have cost > $0 AND ALL date fields are NOT in the target date range</li>
                    <li><strong>Open Enrollment v3.7:</strong> Copy ALL rows from Sheet 1 where SSN exists in BOTH sheets OR fuzzy matching finds policy matches</li>
                    <li>Multiple rows per SSN copied exactly as-is (no consolidation in Open Enrollment mode)</li>
                    <li>Single Sheet: Dollar amounts summed across all rows per SSN with consolidation</li>
                    <li>Open Enrollment: Rows copied exactly - no data consolidation or summation</li>
                    <li><strong>ENHANCED:</strong> SSN detection scans actual data patterns (XXX-XX-XXXX, XXXXXXXXX, XXX XX XXXX)</li>
                </ul>
            </div>
        </div>
        
        <button class="button step2" id="processBtn" type="button" disabled>
            Step 2: Process
        </button>
        
        <button class="button open-enrollment" id="openEnrollmentBtn" type="button" style="display: none;" disabled>
            Step 2: Open Enrollment
        </button>
        
        <div id="auditSection" class="audit-section">
            <h3>Open Enrollment Configuration</h3>
            <div class="sheet-selection">
                <h4 id="sheet1Name">Sheet 1 SSN Field:</h4>
                <div id="sheet1SSNFields"></div>
            </div>
            <div class="sheet-selection">
                <h4 id="sheet2Name">Sheet 2 SSN Field:</h4>
                <div id="sheet2SSNFields"></div>
            </div>
            <div class="open-enrollment-info">
                <strong>Open Enrollment Process v3.7:</strong> Copies ALL rows from Sheet 1 where SSN exists in BOTH sheets OR fuzzy matching finds policy matches between sheets. No data consolidation - rows copied exactly as they appear in Sheet 1.
            </div>
        </div>
        
        <div class="progress" id="progressContainer" style="display: none;">
            <div class="progress-bar" id="progressBar"></div>
        </div>
        
        <div id="status" class="status" style="display: none;"></div>
        
        <div id="debugInfo" class="debug-info" style="display: none;"></div>
    </div>

    <script>
        console.log('=== SCRIPT LOADING - VERSION 3.7 CONCEPT CHANGE ===');
        
        let detectedHeaders = [];
        let currentSheetData = [];
        let selectedSSNFields = [];
        let detectedDateFields = [];
        let detectedCostFields = [];
        let policyChangeDate = null;
        let debugMode = false;
        let officeReady = false;
        let worksheetCount = 0;
        let allSheetsData = [];
        let hasSSNInBothSheets = false;
        let selectedSheet1SSN = '';
        let selectedSheet2SSN = '';
        
        // PRESERVED - Healthcare abbreviations mapping (unchanged from v3.5)
        const healthcareAbbreviations = {
            'EE': 'Employee Only',
            'ES': 'Employee + Spouse', 
            'EC': 'Employee + Child(ren)',
            'EF': 'Employee + Family',
            'EES': 'Employee + Eligible Spouse',
            'EEC': 'Employee + Eligible Child(ren)', 
            'EEF': 'Employee + Eligible Family',
            'SP': 'Spouse Only',
            'CH': 'Child Only',
            'FAM': 'Family Coverage',
            'IND': 'Individual Coverage',
            'DEP': 'Dependent Coverage',
            '2P': 'Two Person Coverage',
            '1P': 'One Person Coverage',
            'FTE': 'Full-Time Employee',
            'PTE': 'Part-Time Employee',
            'RET': 'Retiree',
            'COBRA': 'Continuation Coverage',
            'MEC': 'Minimum Essential Coverage',
            'HDHP': 'High Deductible Health Plan',
            'HMO': 'Health Maintenance Organization',
            'PPO': 'Preferred Provider Organization',
            'POS': 'Point of Service',
            'EPO': 'Exclusive Provider Organization',
            'DHMO': 'Dental Health Maintenance Organization',
            'DPPO': 'Dental Preferred Provider Organization',
            'DMO': 'Dental Maintenance Organization',
            'DEN': 'Dental Coverage',
            'VIS': 'Vision Coverage',
            'MH': 'Mental Health Coverage',
            'RX': 'Prescription Drug Coverage',
            'LTC': 'Long-Term Care'
        };

        Office.onReady((info) => {
            console.log('=== OFFICE.JS READY - VERSION 3.7 CONCEPT CHANGE ===');
            console.log('Host:', info.host);
            console.log('Platform:', info.platform);
            
            officeReady = true;
            updateStepIndicators('none');
            
            const today = new Date();
            document.getElementById('policyDate').value = today.toISOString().split('T')[0];
            
            const urlParams = new URLSearchParams(window.location.search);
            debugMode = urlParams.get('debug') === 'true';
            
            if (debugMode) {
                document.getElementById('debugInfo').style.display = 'block';
                debugLog('Debug mode enabled - Version 3.7 CONCEPT CHANGE');
            }
            
            setTimeout(setupEventListeners, 100);
        });

        // PRESERVED FUNCTIONALITY - All SSN detection and field analysis functions (unchanged from v3.5)
        function isSSNPattern(value) {
            if (!value) return false;
            
            const cleanValue = String(value).replace(/\s+/g, '').trim();
            
            if (/^\d{3}-\d{2}-\d{4}$/.test(cleanValue)) {
                debugLog(`  SSN Pattern Match (XXX-XX-XXXX): "${cleanValue}"`);
                return true;
            }
            
            if (/^\d{9}$/.test(cleanValue)) {
                debugLog(`  SSN Pattern Match (XXXXXXXXX): "${cleanValue}"`);
                return true;
            }
            
            const originalValue = String(value).trim();
            if (/^\d{3}\s\d{2}\s\d{4}$/.test(originalValue)) {
                debugLog(`  SSN Pattern Match (XXX XX XXXX): "${originalValue}"`);
                return true;
            }
            
            if (/^\d{3}\s\d{6}$/.test(originalValue)) {
                debugLog(`  SSN Pattern Match (XXX XXXXXX): "${originalValue}"`);
                return true;
            }
            
            return false;
        }

        function scanColumnForSSNPatterns(data, columnIndex, headerName) {
            let ssnCount = 0;
            let totalNonEmptyValues = 0;
            const sampleValues = [];
            
            debugLog(`Scanning column ${columnIndex} ("${headerName}") for SSN patterns...`);
            
            const scanRows = Math.min(10, data.length - 1);
            for (let i = 1; i <= scanRows; i++) {
                if (i < data.length && data[i] && data[i][columnIndex] !== undefined) {
                    const value = data[i][columnIndex];
                    if (value !== null && value !== '' && value !== undefined) {
                        totalNonEmptyValues++;
                        
                        if (isSSNPattern(value)) {
                            ssnCount++;
                            sampleValues.push(String(value));
                        }
                    }
                }
            }
            
            const ssnPercentage = totalNonEmptyValues > 0 ? (ssnCount / totalNonEmptyValues) : 0;
            const isSSNColumn = ssnPercentage >= 0.7;
            
            debugLog(`  Scanned ${scanRows} rows: ${ssnCount}/${totalNonEmptyValues} SSN patterns (${(ssnPercentage * 100).toFixed(1)}%)`);
            if (sampleValues.length > 0) {
                debugLog(`  Sample SSN values: ${sampleValues.slice(0, 3).join(', ')}`);
            }
            debugLog(`  Column "${headerName}" SSN detection: ${isSSNColumn ? 'DETECTED' : 'NOT DETECTED'}`);
            
            return {
                isSSN: isSSNColumn,
                ssnCount: ssnCount,
                totalValues: totalNonEmptyValues,
                percentage: ssnPercentage,
                samples: sampleValues.slice(0, 3)
            };
        }

        function detectFields(headers, data = null) {
            const ssnFields = [];
            const dateFields = [];
            const costFields = [];
            
            debugLog(`=== ENHANCED FIELD DETECTION v3.7 ===`);
            debugLog(`Detecting fields in ${headers.length} headers with ${data ? 'DATA SCANNING' : 'HEADER-ONLY'} analysis`);
            
            headers.forEach((header, index) => {
                if (typeof header === 'string') {
                    const headerLower = header.toLowerCase().trim();
                    
                    let isSSNByHeader = false;
                    let isSSNByData = false;
                    let detectionMethod = '';
                    
                    if (headerLower.includes('ssn') || 
                        headerLower.includes('social security') ||
                        headerLower.includes('social security number') ||
                        headerLower.includes('employee ssn') ||
                        headerLower.includes('emp ssn') ||
                        headerLower.includes('socialSecurity') ||
                        headerLower === 'ssn' ||
                        headerLower === 'social' ||
                        (headerLower.includes('social') && headerLower.includes('security')) ||
                        (headerLower.includes('social') && headerLower.includes('number'))) {
                        isSSNByHeader = true;
                        detectionMethod = 'header';
                    }
                    
                    if (data && data.length > 1) {
                        const dataAnalysis = scanColumnForSSNPatterns(data, index, header);
                        if (dataAnalysis.isSSN) {
                            isSSNByData = true;
                            detectionMethod = isSSNByHeader ? 'header+data' : 'data';
                        }
                    }
                    
                    if (isSSNByHeader || isSSNByData) {
                        ssnFields.push({ 
                            name: header, 
                            index: index, 
                            detectionMethod: detectionMethod,
                            byHeader: isSSNByHeader,
                            byData: isSSNByData
                        });
                        debugLog(`  âœ" SSN field found: "${header}" (${detectionMethod})`);
                    }
                    
                    if (headerLower.includes('date') || 
                        headerLower.includes('dob') ||
                        headerLower.includes('enrolled') ||
                        headerLower.includes('hire') ||
                        headerLower.includes('start') ||
                        headerLower.includes('effective') ||
                        headerLower.includes('created') ||
                        headerLower.includes('modified')) {
                        dateFields.push({ name: header, index: index });
                        debugLog(`  âœ" Date field found: "${header}"`);
                    }
                    
                    if (headerLower.includes('cost') || 
                        headerLower.includes('amount') || 
                        headerLower.includes('fee') || 
                        headerLower.includes('price') || 
                        headerLower.includes('premium') || 
                        headerLower.includes('rate') ||
                        headerLower.includes('total') ||
                        headerLower.includes('charge')) {
                        costFields.push({ name: header, index: index });
                        debugLog(`  âœ" Cost field found: "${header}"`);
                    }
                }
            });
            
            debugLog(`=== FIELD DETECTION COMPLETE ===`);
            debugLog(`Found ${ssnFields.length} SSN fields, ${dateFields.length} date fields, ${costFields.length} cost fields`);
            
            return { ssnFields, dateFields, costFields };
        }

        // PRESERVED FUNCTIONALITY - All sheet loading and analysis functions (unchanged from v3.5)
        async function loadSheetData(sheet, context) {
            try {
                const usedRange = sheet.getUsedRange();
                usedRange.load("values");
                await context.sync();
                
                if (!usedRange.isNullObject && usedRange.values && usedRange.values.length > 0) {
                    return {
                        name: sheet.name,
                        data: usedRange.values,
                        headers: usedRange.values[0],
                        index: sheet.position,
                        hasData: true
                    };
                } else {
                    debugLog(`  Sheet "${sheet.name}" has no data or is empty`);
                    return {
                        name: sheet.name,
                        data: null,
                        headers: null,
                        index: sheet.position,
                        hasData: false
                    };
                }
            } catch (error) {
                debugLog(`  Error loading sheet "${sheet.name}": ${error.message}`);
                return {
                    name: sheet.name,
                    data: null,
                    headers: null,
                    index: sheet.position,
                    hasData: false,
                    error: error.message
                };
            }
        }

        function analyzeSheetForSSNFields(sheetData) {
            if (!sheetData.hasData || !sheetData.headers) {
                return {
                    sheetData: sheetData,
                    ssnFields: [],
                    hasSSN: false,
                    dateFields: [],
                    costFields: []
                };
            }
            
            const fieldAnalysis = detectFields(sheetData.headers, sheetData.data);
            const hasSSN = fieldAnalysis.ssnFields.length > 0;
            
            debugLog(`  Sheet "${sheetData.name}" analysis: ${fieldAnalysis.ssnFields.length} SSN fields, ${fieldAnalysis.dateFields.length} date fields, ${fieldAnalysis.costFields.length} cost fields`);
            fieldAnalysis.ssnFields.forEach(field => {
                debugLog(`    SSN Field: "${field.name}" (${field.detectionMethod})`);
            });
            
            return {
                sheetData: sheetData,
                ssnFields: fieldAnalysis.ssnFields,
                hasSSN: hasSSN,
                dateFields: fieldAnalysis.dateFields,
                costFields: fieldAnalysis.costFields
            };
        }

        async function checkWorksheetCount() {
            try {
                debugLog('=== CHECKING ALL WORKSHEETS v3.7 ===');
                await Excel.run(async (context) => {
                    const worksheets = context.workbook.worksheets;
                    worksheets.load("count, items/name, items/position");
                    await context.sync();
                    
                    worksheetCount = worksheets.count;
                    debugLog(`Detected ${worksheetCount} total worksheets`);
                    
                    if (worksheetCount < 2) {
                        hasSSNInBothSheets = false;
                        debugLog('Insufficient worksheets for Open Enrollment mode');
                        return;
                    }
                    
                    const allSheetAnalysis = [];
                    debugLog('=== LOADING ALL SHEET DATA ===');
                    
                    for (let i = 0; i < worksheets.items.length; i++) {
                        const sheet = worksheets.items[i];
                        debugLog(`Loading sheet ${i}: "${sheet.name}" (position: ${sheet.position})`);
                        
                        const sheetData = await loadSheetData(sheet, context);
                        const analysis = analyzeSheetForSSNFields(sheetData);
                        allSheetAnalysis.push(analysis);
                    }
                    
                    const sheetsWithSSN = allSheetAnalysis
                        .filter(analysis => analysis.hasSSN)
                        .sort((a, b) => a.sheetData.index - b.sheetData.index);
                    
                    debugLog(`=== SSN ANALYSIS RESULTS ===`);
                    debugLog(`Total sheets analyzed: ${allSheetAnalysis.length}`);
                    debugLog(`Sheets with SSN fields: ${sheetsWithSSN.length}`);
                    
                    if (sheetsWithSSN.length >= 2) {
                        const firstTwoSSNSheets = sheetsWithSSN.slice(0, 2);
                        allSheetsData = firstTwoSSNSheets.map(analysis => analysis.sheetData);
                        
                        debugLog(`Selected first two SSN-enabled sheets:`);
                        debugLog(`  Sheet 1: "${allSheetsData[0].name}" (position ${allSheetsData[0].index})`);
                        debugLog(`  Sheet 2: "${allSheetsData[1].name}" (position ${allSheetsData[1].index})`);
                        
                        hasSSNInBothSheets = true;
                        createTwoSheetSSNSelections(firstTwoSSNSheets);
                        
                    } else {
                        hasSSNInBothSheets = false;
                        allSheetsData = [];
                        debugLog(`Insufficient SSN-enabled sheets for Open Enrollment (found ${sheetsWithSSN.length}, need 2)`);
                    }
                    
                    debugLog(`=== FINAL MULTI-SHEET RESULT: ${hasSSNInBothSheets} ===`);
                });
            } catch (error) {
                debugLog('Error checking worksheets: ' + error.message);
                console.error('Worksheet analysis error:', error);
                hasSSNInBothSheets = false;
                allSheetsData = [];
            }
        }

        // PRESERVED FUNCTIONALITY - All UI and event handling functions (unchanged from v3.5)
        function updateButtonStates() {
            const processBtn = document.getElementById('processBtn');
            const openEnrollmentBtn = document.getElementById('openEnrollmentBtn');
            const auditSection = document.getElementById('auditSection');
            
            debugLog(`=== UPDATING BUTTON STATES v3.7 ===`);
            debugLog(`Selected SSN fields: ${selectedSSNFields.length}`);
            debugLog(`Has SSN in both sheets: ${hasSSNInBothSheets}`);
            debugLog(`Sheet1 SSN: "${selectedSheet1SSN}"`);
            debugLog(`Sheet2 SSN: "${selectedSheet2SSN}"`);
            
            if (selectedSSNFields.length === 1) {
                if (hasSSNInBothSheets) {
                    processBtn.style.display = 'none';
                    openEnrollmentBtn.style.display = 'block';
                    auditSection.style.display = 'block';
                    
                    if (selectedSheet1SSN && selectedSheet2SSN) {
                        openEnrollmentBtn.disabled = false;
                        showStatus(`Ready for Open Enrollment processing with selected SSN fields`, 'success');
                        debugLog(`âœ" Open Enrollment button ENABLED`);
                    } else {
                        openEnrollmentBtn.disabled = true;
                        showStatus('Please select SSN fields from both sheets below', 'info');
                        debugLog(`âœ— Open Enrollment button DISABLED - missing sheet SSN selections`);
                    }
                } else {
                    processBtn.style.display = 'block';
                    processBtn.disabled = false;
                    openEnrollmentBtn.style.display = 'none';
                    auditSection.style.display = 'none';
                    showStatus(`Ready to process with SSN field: ${selectedSSNFields[0]}`, 'success');
                    debugLog(`âœ" Process button ENABLED`);
                }
            } else if (selectedSSNFields.length === 0) {
                processBtn.disabled = true;
                openEnrollmentBtn.disabled = true;
                auditSection.style.display = 'none';
                showStatus('Please select exactly one SSN field to continue', 'error');
                debugLog(`âœ— No SSN field selected`);
            } else {
                processBtn.disabled = true;
                openEnrollmentBtn.disabled = true;
                auditSection.style.display = 'none';
                showStatus('Please select only one SSN field. Multiple SSN fields are not supported.', 'error');
                debugLog(`âœ— Multiple SSN fields selected`);
            }
        }

        function createTwoSheetSSNSelections(sheetAnalyses) {
            if (sheetAnalyses.length < 2) return;
            
            const sheet1Analysis = sheetAnalyses[0];
            const sheet2Analysis = sheetAnalyses[1];
            
            document.getElementById('sheet1Name').textContent = `${sheet1Analysis.sheetData.name} SSN Field:`;
            document.getElementById('sheet2Name').textContent = `${sheet2Analysis.sheetData.name} SSN Field:`;
            
            createSheetSSNCheckboxes('sheet1SSNFields', sheet1Analysis.ssnFields, 'sheet1');
            createSheetSSNCheckboxes('sheet2SSNFields', sheet2Analysis.ssnFields, 'sheet2');
            
            initializeSheetSSNSelections();
            
            debugLog('Created SSN field selections for first two SSN-enabled sheets');
        }

        function initializeSheetSSNSelections() {
            debugLog('=== INITIALIZING SHEET SSN SELECTIONS ===');
            
            const sheet1Radio = document.querySelector('input[name="sheet1_ssn"]:checked');
            const sheet2Radio = document.querySelector('input[name="sheet2_ssn"]:checked');
            
            selectedSheet1SSN = sheet1Radio ? sheet1Radio.value : '';
            selectedSheet2SSN = sheet2Radio ? sheet2Radio.value : '';
            
            debugLog(`Initial Sheet1 SSN: "${selectedSheet1SSN}"`);
            debugLog(`Initial Sheet2 SSN: "${selectedSheet2SSN}"`);
            
            updateButtonStates();
        }

        function updateTwoSheetSelections() {
            debugLog('=== UPDATING TWO SHEET SELECTIONS ===');
            
            const sheet1Radio = document.querySelector('input[name="sheet1_ssn"]:checked');
            const sheet2Radio = document.querySelector('input[name="sheet2_ssn"]:checked');
            
            selectedSheet1SSN = sheet1Radio ? sheet1Radio.value : '';
            selectedSheet2SSN = sheet2Radio ? sheet2Radio.value : '';
            
            debugLog(`Updated Sheet1 SSN: "${selectedSheet1SSN}"`);
            debugLog(`Updated Sheet2 SSN: "${selectedSheet2SSN}"`);
            
            updateButtonStates();
        }

        function createSheetSSNCheckboxes(containerId, ssnFields, sheetPrefix) {
            const container = document.getElementById(containerId);
            container.innerHTML = '';
            
            if (ssnFields.length === 0) {
                container.innerHTML = '<div style="color: #6c757d; font-style: italic;">No SSN fields detected</div>';
                return;
            }
            
            ssnFields.forEach((field, index) => {
                const checkboxDiv = document.createElement('div');
                checkboxDiv.className = field.byData ? 'field-checkbox data-detected' : 'field-checkbox highlighted';
                
                const checkbox = document.createElement('input');
                checkbox.type = 'radio';
                checkbox.name = `${sheetPrefix}_ssn`;
                checkbox.id = `${sheetPrefix}_ssn_${index}`;
                checkbox.value = field.name;
                checkbox.checked = index === 0;
                checkbox.addEventListener('change', updateTwoSheetSelections);
                
                const label = document.createElement('label');
                label.htmlFor = `${sheetPrefix}_ssn_${index}`;
                label.textContent = `${field.name} (${field.detectionMethod})`;
                
                checkboxDiv.appendChild(checkbox);
                checkboxDiv.appendChild(label);
                container.appendChild(checkboxDiv);
            });
        }

        function setupEventListeners() {
            const analyzeBtn = document.getElementById('analyzeBtn');
            const processBtn = document.getElementById('processBtn');
            const openEnrollmentBtn = document.getElementById('openEnrollmentBtn');
            
            if (analyzeBtn) {
                analyzeBtn.addEventListener('click', function(event) {
                    event.preventDefault();
                    if (officeReady) analyzeCurrentSheet();
                });
            }
            
            if (processBtn) {
                processBtn.addEventListener('click', function(event) {
                    event.preventDefault();
                    if (officeReady) processEnrollmentData();
                });
            }
            
            if (openEnrollmentBtn) {
                openEnrollmentBtn.addEventListener('click', function(event) {
                    event.preventDefault();
                    if (officeReady) runOpenEnrollmentProcess();
                });
            }
        }

        // PRESERVED FUNCTIONALITY - All utility functions (unchanged from v3.5)
        function debugLog(message) {
            const timestamp = new Date().toLocaleTimeString();
            console.log(`[${timestamp}] ${message}`);
            
            if (debugMode) {
                const debugDiv = document.getElementById('debugInfo');
                if (debugDiv) {
                    debugDiv.innerHTML += `<div>[${timestamp}] ${message}</div>`;
                    debugDiv.scrollTop = debugDiv.scrollHeight;
                }
            }
        }

        function updateStepIndicators(currentStep) {
            const step1 = document.getElementById('step1Indicator');
            const step2 = document.getElementById('step2Indicator');
            
            step1.className = 'step';
            step2.className = 'step';
            
            if (currentStep === 'analyze') {
                step1.className = 'step active';
            } else if (currentStep === 'process') {
                step1.className = 'step completed';
                step2.className = 'step active';
            } else if (currentStep === 'completed') {
                step1.className = 'step completed';
                step2.className = 'step completed';
            }
        }

        function showStatus(message, type = 'info') {
            const statusDiv = document.getElementById('status');
            statusDiv.textContent = message;
            statusDiv.className = `status ${type}`;
            statusDiv.style.display = 'block';
            debugLog(`Status: ${type.toUpperCase()} - ${message}`);
        }

        function updateProgress(percentage) {
            const progressContainer = document.getElementById('progressContainer');
            const progressBar = document.getElementById('progressBar');
            
            if (percentage > 0) {
                progressContainer.style.display = 'block';
                progressBar.style.width = percentage + '%';
            } else {
                progressContainer.style.display = 'none';
            }
        }

        function createSSNFieldCheckboxes(fields) {
            const container = document.getElementById('ssnFieldCheckboxes');
            container.innerHTML = '';
            
            if (fields.length === 0) {
                container.innerHTML = '<div style="color: #6c757d; font-style: italic;">No SSN fields detected</div>';
                return;
            }
            
            fields.forEach((field, index) => {
                const checkboxDiv = document.createElement('div');
                checkboxDiv.className = field.byData ? 'field-checkbox data-detected' : 'field-checkbox highlighted';
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `ssn_${index}`;
                checkbox.value = field.name;
                checkbox.checked = index === 0;
                checkbox.addEventListener('change', updateSelectedFields);
                
                const label = document.createElement('label');
                label.htmlFor = `ssn_${index}`;
                label.textContent = `${field.name} (${field.detectionMethod})`;
                
                checkboxDiv.appendChild(checkbox);
                checkboxDiv.appendChild(label);
                container.appendChild(checkboxDiv);
            });
        }

        function displayDateFields(fields) {
            const dateFieldsList = document.getElementById('dateFieldsList');
            dateFieldsList.textContent = fields.length > 0 ? fields.map(f => f.name).join(', ') : 'None detected';
        }

        function displayCostFields(fields) {
            const costFieldsList = document.getElementById('costFieldsList');
            costFieldsList.textContent = fields.length > 0 ? fields.map(f => f.name).join(', ') : 'None detected';
        }

        function updateSelectedFields() {
            selectedSSNFields = [];
            
            const ssnCheckboxes = document.querySelectorAll('#ssnFieldCheckboxes input[type="checkbox"]:checked');
            ssnCheckboxes.forEach(checkbox => {
                selectedSSNFields.push(checkbox.value);
            });
            
            updateButtonStates();
        }

        async function analyzeCurrentSheet() {
            try {
                debugLog('=== STARTING ANALYSIS v3.7 CONCEPT CHANGE ===');
                
                const dateInput = document.getElementById('policyDate');
                if (!dateInput.value) {
                    showStatus('Please select a policy change date first', 'error');
                    return;
                }
                
                policyChangeDate = new Date(dateInput.value);
                debugLog(`Policy change date set to: ${policyChangeDate.toLocaleDateString()}`);
                
                updateStepIndicators('analyze');
                showStatus('Analyzing all sheets with enhanced SSN detection...', 'info');
                updateProgress(10);
                
                await checkWorksheetCount();
                
                updateProgress(25);
                debugLog(`After worksheet check: hasSSNInBothSheets = ${hasSSNInBothSheets}`);
                
                await Excel.run(async (context) => {
                    const worksheet = context.workbook.worksheets.getActiveWorksheet();
                    const usedRange = worksheet.getUsedRange();
                    
                    usedRange.load("values");
                    await context.sync();
                    
                    if (usedRange.isNullObject) {
                        showStatus('No data found in the current sheet', 'error');
                        return;
                    }
                    
                    const data = usedRange.values;
                    
                    if (!data || data.length === 0) {
                        showStatus('No data found in the current sheet', 'error');
                        return;
                    }
                    
                    updateProgress(50);
                    
                    currentSheetData = data;
                    detectedHeaders = data[0];
                    debugLog(`Loaded ${data.length} rows with ${detectedHeaders.length} columns from active sheet`);
                    
                    const { ssnFields, dateFields, costFields } = detectFields(detectedHeaders, data);
                    detectedDateFields = dateFields;
                    detectedCostFields = costFields;
                    
                    debugLog(`Active sheet SSN fields found: ${ssnFields.length}`);
                    ssnFields.forEach(field => debugLog(`  - ${field.name} (${field.detectionMethod})`));
                    
                    updateProgress(75);
                    
                    createSSNFieldCheckboxes(ssnFields);
                    displayDateFields(dateFields);
                    displayCostFields(costFields);
                    
                    document.getElementById('fieldSelection').style.display = 'block';
                    
                    debugLog(`About to call updateSelectedFields with hasSSNInBothSheets = ${hasSSNInBothSheets}`);
                    updateSelectedFields();
                    
                    updateProgress(100);
                    setTimeout(() => updateProgress(0), 1000);
                    
                    debugLog(`=== ANALYSIS COMPLETE v3.7 CONCEPT CHANGE ===`);
                    debugLog(`Multi-sheet mode: ${hasSSNInBothSheets}`);
                });
                
            } catch (error) {
                showStatus('Error analyzing sheet: ' + error.message, 'error');
                debugLog('Analysis error: ' + error.message);
                console.error('Analysis error:', error);
                updateProgress(0);
            }
        }

        // NEW v3.7 FUNCTIONALITY - Updated Open Enrollment Process
        async function runOpenEnrollmentProcess() {
            try {
                debugLog('=== STARTING OPEN ENROLLMENT PROCESS v3.7 CONCEPT CHANGE ===');
                showStatus('Running Open Enrollment processing...', 'info');
                updateProgress(10);
                
                if (!hasSSNInBothSheets || allSheetsData.length < 2) {
                    showStatus('Open Enrollment requires 2 sheets with SSN fields', 'error');
                    return;
                }
                
                if (!selectedSheet1SSN || !selectedSheet2SSN) {
                    showStatus('Please select SSN fields from both sheets', 'error');
                    return;
                }
                
                debugLog(`Using selected SSN fields: "${selectedSheet1SSN}" and "${selectedSheet2SSN}"`);
                
                await Excel.run(async (context) => {
                    updateProgress(25);
                    
                    const sheet1Data = allSheetsData[0];
                    const sheet2Data = allSheetsData[1];
                    
                    debugLog(`Processing: ${sheet1Data.name} (${sheet1Data.data.length} rows) and ${sheet2Data.name} (${sheet2Data.data.length} rows)`);
                    
                    updateProgress(50);
                    
                    // NEW v3.7 LOGIC: Process with concept change
                    const openEnrollmentResults = processOpenEnrollmentDataV37(
                        sheet1Data.data, sheet1Data.headers, selectedSheet1SSN,
                        sheet2Data.data, sheet2Data.headers, selectedSheet2SSN
                    );
                    
                    updateProgress(75);
                    
                    // Create Open Enrollment Report sheet
                    await createOpenEnrollmentReportSheetV37(context, openEnrollmentResults, sheet1Data.headers, sheet2Data.headers);
                    
                    updateProgress(100);
                    showStatus(`Open Enrollment processing completed! Copied ${openEnrollmentResults.totalRowsCopied} rows from ${allSheetsData[0].name}.`, 'success');
                    setTimeout(() => updateProgress(0), 1000);
                });
                
            } catch (error) {
                showStatus('Error running Open Enrollment process: ' + error.message, 'error');
                debugLog('Open Enrollment error: ' + error.message);
                console.error('Open Enrollment error:', error);
                updateProgress(0);
            }
        }

        // NEW v3.7 FUNCTIONALITY - Process Open Enrollment Data with Concept Change
        function processOpenEnrollmentDataV37(sheet1Data, sheet1Headers, sheet1SSNField, sheet2Data, sheet2Headers, sheet2SSNField) {
            debugLog('=== PROCESSING OPEN ENROLLMENT DATA v3.7 - CONCEPT CHANGE ===');
            debugLog('New logic: Copy ALL rows from Sheet 1 where SSN exists in BOTH sheets OR fuzzy matching finds policy matches');
            
            const sheet1SSNIndex = sheet1Headers.indexOf(sheet1SSNField);
            const sheet2SSNIndex = sheet2Headers.indexOf(sheet2SSNField);
            
            // Group data by SSN for both sheets
            const sheet1BySSN = {};
            const sheet2BySSN = {};
            
            // Process Sheet 1
            for (let i = 1; i < sheet1Data.length; i++) {
                const row = sheet1Data[i];
                const ssn = formatSSN(row[sheet1SSNIndex]);
                if (ssn) {
                    if (!sheet1BySSN[ssn]) sheet1BySSN[ssn] = [];
                    sheet1BySSN[ssn].push(row);
                }
            }
            
            // Process Sheet 2
            for (let i = 1; i < sheet2Data.length; i++) {
                const row = sheet2Data[i];
                const ssn = formatSSN(row[sheet2SSNIndex]);
                if (ssn) {
                    if (!sheet2BySSN[ssn]) sheet2BySSN[ssn] = [];
                    sheet2BySSN[ssn].push(row);
                }
            }
            
            const resultRows = [];
            const includedSSNs = new Set();
            const ssnWithBothSheets = new Set();
            const ssnWithPolicyMatches = new Set();
            
            debugLog(`Found ${Object.keys(sheet1BySSN).length} unique SSNs in Sheet 1`);
            debugLog(`Found ${Object.keys(sheet2BySSN).length} unique SSNs in Sheet 2`);
            
            // Process each SSN from Sheet 1
            for (const [ssn, sheet1Rows] of Object.entries(sheet1BySSN)) {
                const sheet2Rows = sheet2BySSN[ssn];
                let shouldInclude = false;
                let inclusionReason = '';
                
                // Condition 1: SSN exists in BOTH sheets
                if (sheet2Rows) {
                    shouldInclude = true;
                    inclusionReason = 'SSN exists in both sheets';
                    ssnWithBothSheets.add(ssn);
                    debugLog(`SSN ${ssn}: EXISTS IN BOTH SHEETS - INCLUDE`);
                } else {
                    // Condition 2: SSN NOT in Sheet 2, but check for fuzzy policy matches
                    debugLog(`SSN ${ssn}: Not in Sheet 2, checking for policy matches...`);
                    
                    // Check if any data from this SSN in Sheet 1 has policy matches with any data in Sheet 2
                    let hasPolicyMatch = false;
                    
                    // Convert Sheet 1 rows to objects for easier processing
                    const sheet1Objects = sheet1Rows.map(row => {
                        const obj = {};
                        sheet1Headers.forEach((header, index) => {
                            obj[header] = row[index];
                        });
                        return obj;
                    });
                    
                    // Check all Sheet 2 data for policy matches
                    outerLoop: for (let i = 1; i < sheet2Data.length; i++) {
                        const sheet2Row = sheet2Data[i];
                        
                        // Check each non-SSN, non-date field in Sheet 2 row
                        for (let fieldIndex = 0; fieldIndex < sheet2Headers.length; fieldIndex++) {
                            const header = sheet2Headers[fieldIndex];
                            const sheet2Value = sheet2Row[fieldIndex];
                            
                            if (sheet2Value && header !== sheet2SSNField && !isDateField(header)) {
                                // Use existing fuzzy matching to find policy matches
                                const match = findMatchingCoverage(sheet2Value, sheet1Objects, sheet1Headers);
                                
                                if (match) {
                                    hasPolicyMatch = true;
                                    debugLog(`  SSN ${ssn}: Found policy match "${sheet2Value}" -> "${match.value}" - INCLUDE`);
                                    break outerLoop;
                                }
                            }
                        }
                    }
                    
                    if (hasPolicyMatch) {
                        shouldInclude = true;
                        inclusionReason = 'fuzzy policy match found';
                        ssnWithPolicyMatches.add(ssn);
                    } else {
                        debugLog(`  SSN ${ssn}: No policy matches found - EXCLUDE`);
                    }
                }
                
                if (shouldInclude) {
                    includedSSNs.add(ssn);
                    
                    // Copy ALL rows for this SSN exactly as they are (no consolidation)
                    sheet1Rows.forEach(row => {
                        resultRows.push({
                            data: row,
                            headers: sheet1Headers,
                            source: allSheetsData[0].name,
                            ssn: ssn,
                            inclusionReason: inclusionReason
                        });
                    });
                    
                    debugLog(`  SSN ${ssn}: INCLUDED (${inclusionReason}) - copied ${sheet1Rows.length} rows`);
                }
            }
            
            debugLog(`=== OPEN ENROLLMENT RESULTS v3.7 ===`);
            debugLog(`Total SSNs in Sheet 1: ${Object.keys(sheet1BySSN).length}`);
            debugLog(`SSNs existing in both sheets: ${ssnWithBothSheets.size}`);
            debugLog(`SSNs with policy matches: ${ssnWithPolicyMatches.size}`);
            debugLog(`Total included SSNs: ${includedSSNs.size}`);
            debugLog(`Total rows copied from Sheet 1: ${resultRows.length}`);
            
            return {
                rows: resultRows,
                totalSheet1SSNs: Object.keys(sheet1BySSN).length,
                includedSSNs: includedSSNs.size,
                ssnWithBothSheets: ssnWithBothSheets.size,
                ssnWithPolicyMatches: ssnWithPolicyMatches.size,
                totalRowsCopied: resultRows.length
            };
        }

        // NEW v3.7 FUNCTIONALITY - Create Open Enrollment Report Sheet
        async function createOpenEnrollmentReportSheetV37(context, results, sheet1Headers, sheet2Headers) {
            try {
                debugLog('Creating Open Enrollment Report sheet v3.7...');
                
                // Delete existing sheet if it exists
                try {
                    const existingSheet = context.workbook.worksheets.getItem("Open Enrollment Report");
                    existingSheet.delete();
                    await context.sync();
                } catch (e) {
                    // Sheet doesn't exist, continue
                }
                
                const reportSheet = context.workbook.worksheets.add("Open Enrollment Report");
                await context.sync();
                
                if (results.rows.length === 0) {
                    const noDataRange = reportSheet.getRange("A1");
                    noDataRange.values = [["No data to display - no SSNs met the inclusion criteria"]];
                    return;
                }
                
                // Use Sheet 1 headers and add metadata columns
                const reportHeaders = ['INCLUSION_REASON', 'SOURCE_SHEET', ...sheet1Headers];
                
                // Write headers
                const headerRange = reportSheet.getRange(`A1:${getExcelColumnName(reportHeaders.length)}1`);
                headerRange.values = [reportHeaders];
                headerRange.format.font.bold = true;
                headerRange.format.fill.color = "#28a745";
                headerRange.format.font.color = "white";
                await context.sync();
                
                // Write data rows - copy exactly as they are from Sheet 1
                let currentRow = 2;
                for (const result of results.rows) {
                    const rowData = new Array(reportHeaders.length).fill('');
                    
                    // Fill metadata
                    rowData[0] = result.inclusionReason;
                    rowData[1] = result.source;
                    
                    // Fill data from Sheet 1 row exactly as-is
                    result.data.forEach((cellValue, index) => {
                        let value = cellValue;
                        
                        // Format dates properly
                        if (value !== undefined && value !== null && value !== '') {
                            const header = sheet1Headers[index];
                            if (isDateField(header)) {
                                value = formatDateForExcel(value);
                            }
                        } else {
                            value = '';
                        }
                        
                        rowData[index + 2] = value; // +2 because of metadata columns
                    });
                    
                    const rowRange = reportSheet.getRange(`A${currentRow}:${getExcelColumnName(reportHeaders.length)}${currentRow}`);
                    rowRange.values = [rowData];
                    
                    // Color code by inclusion reason
                    if (result.inclusionReason === 'SSN exists in both sheets') {
                        rowRange.format.fill.color = "#e3f2fd"; // Light blue
                    } else if (result.inclusionReason === 'fuzzy policy match found') {
                        rowRange.format.fill.color = "#fff3e0"; // Light orange
                    }
                    
                    currentRow++;
                    
                    if (currentRow % 25 === 0) {
                        await context.sync();
                    }
                }
                
                await context.sync();
                
                // Format date columns properly
                sheet1Headers.forEach((header, index) => {
                    if (isDateField(header)) {
                        const columnRange = reportSheet.getRange(`${getExcelColumnName(index + 3)}:${getExcelColumnName(index + 3)}`);
                        columnRange.numberFormat = [["mm/dd/yyyy"]];
                    }
                });
                
                await context.sync();
                
                // Auto-fit columns
                reportSheet.getUsedRange().format.autofitColumns();
                await context.sync();
                
                // Add summary
                const summaryRow = currentRow + 2;
                const summaryData = [
                    ['OPEN ENROLLMENT SUMMARY v3.7 (CONCEPT CHANGE)', ''],
                    ['Source Sheet', allSheetsData[0].name],
                    ['Reference Sheet', allSheetsData[1].name],
                    ['Total SSNs in Source Sheet', results.totalSheet1SSNs],
                    ['SSNs in Both Sheets', results.ssnWithBothSheets],
                    ['SSNs with Policy Matches Only', results.ssnWithPolicyMatches],
                    ['Total Included SSNs', results.includedSSNs],
                    ['Total Rows Copied from Sheet 1', results.totalRowsCopied],
                    ['Processing Logic v3.7', 'Copy ALL rows from Sheet 1 where: (1) SSN exists in BOTH sheets OR (2) fuzzy matching finds policy matches'],
                    ['No Data Consolidation', 'All rows copied exactly as they appear in Sheet 1'],
                    ['Fuzzy Matching Used', 'Healthcare abbreviation expansion with similarity threshold'],
                    ['Report Generated', new Date().toLocaleString()]
                ];
                
                for (let i = 0; i < summaryData.length; i++) {
                    const summaryRange = reportSheet.getRange(`A${summaryRow + i}:B${summaryRow + i}`);
                    summaryRange.values = [summaryData[i]];
                    if (i === 0) {
                        summaryRange.format.font.bold = true;
                        summaryRange.format.fill.color = "#28a745";
                        summaryRange.format.font.color = "white";
                    }
                }
                
                await context.sync();
                reportSheet.activate();
                await context.sync();
                
                debugLog('Open Enrollment Report sheet created successfully v3.7');
                
            } catch (error) {
                debugLog('Error creating Open Enrollment Report sheet: ' + error.message);
                throw error;
            }
        }

        // PRESERVED FUNCTIONALITY - All fuzzy matching functions (unchanged from v3.5)
        function fuzzyMatch(str1, str2, threshold = 0.6) {
            if (!str1 || !str2) return false;
            
            const s1 = str1.toLowerCase().trim();
            const s2 = str2.toLowerCase().trim();
            
            if (s1 === s2) return true;
            if (s1.includes(s2) || s2.includes(s1)) return true;
            
            const levenshteinDistance = (a, b) => {
                const matrix = [];
                for (let i = 0; i <= b.length; i++) {
                    matrix[i] = [i];
                }
                for (let j = 0; j <= a.length; j++) {
                    matrix[0][j] = j;
                }
                for (let i = 1; i <= b.length; i++) {
                    for (let j = 1; j <= a.length; j++) {
                        if (b.charAt(i - 1) === a.charAt(j - 1)) {
                            matrix[i][j] = matrix[i - 1][j - 1];
                        } else {
                            matrix[i][j] = Math.min(
                                matrix[i - 1][j - 1] + 1,
                                matrix[i][j - 1] + 1,
                                matrix[i - 1][j] + 1
                            );
                        }
                    }
                }
                return matrix[b.length][a.length];
            };
            
            const distance = levenshteinDistance(s1, s2);
            const maxLength = Math.max(s1.length, s2.length);
            const similarity = 1 - (distance / maxLength);
            
            return similarity >= threshold;
        }

        function expandAbbreviation(abbrev) {
            if (!abbrev) return abbrev;
            
            const upperAbbrev = abbrev.toString().toUpperCase().trim();
            
            if (healthcareAbbreviations[upperAbbrev]) {
                return healthcareAbbreviations[upperAbbrev];
            }
            
            for (const [key, value] of Object.entries(healthcareAbbreviations)) {
                if (upperAbbrev.includes(key)) {
                    return value;
                }
            }
            
            return abbrev;
        }

        function findMatchingCoverage(sheet2Value, sheet1Data, headers) {
            if (!sheet2Value) return null;
            
            const expandedValue = expandAbbreviation(sheet2Value);
            debugLog(`Searching for coverage: "${sheet2Value}" (expanded: "${expandedValue}")`);
            
            for (const header of headers) {
                if (isPlanField(header)) {
                    for (const row of sheet1Data) {
                        const sheet1Value = row[header];
                        if (sheet1Value && typeof sheet1Value === 'string') {
                            if (fuzzyMatch(sheet1Value, sheet2Value) || fuzzyMatch(sheet1Value, expandedValue)) {
                                debugLog(`  Found match: "${sheet1Value}" in ${header}`);
                                return {
                                    field: header,
                                    value: sheet1Value,
                                    matchType: 'fuzzy'
                                };
                            }
                        }
                    }
                }
            }
            
            debugLog(`  No match found for "${sheet2Value}"`);
            return null;
        }

        // PRESERVED FUNCTIONALITY - All remaining utility and processing functions (unchanged from v3.5)
        function parseExcelDate(value) {
            if (!value) return null;
            
            if (value instanceof Date) {
                return value;
            }
            
            if (typeof value === 'number' && value > 0) {
                let jsDate;
                
                if (value > 25569) {
                    jsDate = new Date((value - 25569) * 86400 * 1000);
                } else {
                    const excelEpoch = new Date(1900, 0, 1);
                    jsDate = new Date(excelEpoch.getTime() + (value - 1) * 24 * 60 * 60 * 1000);
                    
                    if (value >= 60) {
                        jsDate.setTime(jsDate.getTime() - 24 * 60 * 60 * 1000);
                    }
                }
                
                return jsDate;
            }
            
            if (typeof value === 'string') {
                const cleanStr = value.trim();
                if (cleanStr === '') return null;
                
                const parsed = new Date(cleanStr);
                if (!isNaN(parsed.getTime())) {
                    return parsed;
                }
                
                const dateFormats = [
                    { regex: /^(\d{1,2})\/(\d{1,2})\/(\d{4})$/, order: 'MDY' },
                    { regex: /^(\d{4})-(\d{1,2})-(\d{1,2})$/, order: 'YMD' },
                    { regex: /^(\d{1,2})-(\d{1,2})-(\d{4})$/, order: 'MDY' },
                    { regex: /^(\d{1,2})\/(\d{1,2})\/(\d{2})$/, order: 'MDY2' },
                ];
                
                for (const format of dateFormats) {
                    const match = cleanStr.match(format.regex);
                    if (match) {
                        let year, month, day;
                        
                        if (format.order === 'YMD') {
                            [, year, month, day] = match;
                        } else if (format.order === 'MDY') {
                            [, month, day, year] = match;
                        } else if (format.order === 'MDY2') {
                            [, month, day, year] = match;
                            const yr = parseInt(year);
                            year = yr < 50 ? 2000 + yr : 1900 + yr;
                        }
                        
                        const date = new Date(parseInt(year), parseInt(month) - 1, parseInt(day));
                        if (!isNaN(date.getTime())) {
                            return date;
                        }
                    }
                }
            }
            
            return null;
        }

        function formatDateForExcel(value) {
            if (!value) return '';
            
            const date = parseExcelDate(value);
            if (!date || isNaN(date.getTime())) {
                return value;
            }
            
            const excelEpoch = new Date(1900, 0, 1);
            let serialDate = Math.floor((date.getTime() - excelEpoch.getTime()) / (24 * 60 * 60 * 1000)) + 1;
            
            if (serialDate >= 60) {
                serialDate += 1;
            }
            
            return serialDate;
        }

        function isDateMatch(dateValue, targetDate) {
            if (!dateValue || !targetDate) return false;
            
            const parsedDate = parseExcelDate(dateValue);
            if (!parsedDate || isNaN(parsedDate.getTime())) {
                return false;
            }
            
            return parsedDate.toDateString() === targetDate.toDateString();
        }

        function isZeroOrNull(value) {
            return value === null || 
                   value === undefined || 
                   value === '' || 
                   value === 0 || 
                   (typeof value === 'string' && value.trim() === '') ||
                   (typeof value === 'string' && value.trim() === '0');
        }

        function formatSSN(ssn) {
            if (!ssn) return '';
            
            let ssnStr = ssn.toString().replace(/\D/g, '');
            
            if (ssnStr.length === 9) {
                return ssnStr.substring(0, 3) + '-' + ssnStr.substring(3, 5) + '-' + ssnStr.substring(5);
            }
            
            return ssn.toString();
        }

        function isDollarValue(value) {
            if (typeof value !== 'number') {
                if (typeof value === 'string') {
                    const cleanValue = value.replace(/[$,]/g, '');
                    const parsed = parseFloat(cleanValue);
                    if (!isNaN(parsed)) {
                        value = parsed;
                    } else {
                        return false;
                    }
                } else {
                    return false;
                }
            }
            return value > 0 && value < 10000;
        }

        function isPlanField(header) {
            const headerLower = header.toLowerCase();
            
            const excludeKeywords = ['employee', 'member', 'user', 'person', 'first', 'last', 'full', 
                                   'address', 'street', 'city', 'state', 'zip', 'phone', 'email', 
                                   'ssn', 'social', 'id', 'number', 'birth', 'age', 'gender',
                                   'department', 'title', 'position', 'hire', 'start', 'end',
                                   'salary', 'wage', 'payroll', 'tax'];
            
            for (const exclude of excludeKeywords) {
                if (headerLower.includes(exclude)) {
                    return false;
                }
            }
            
            const planKeywords = ['plan', 'coverage', 'benefit', 'option', 'type', 'product', 
                                'insurance', 'medical', 'dental', 'vision', 'life', 'disability',
                                'health', 'wellness', 'prescription', 'drug', 'pharmacy'];
            
            for (const keyword of planKeywords) {
                if (headerLower.includes(keyword)) {
                    return true;
                }
            }
            
            return false;
        }

        function isCostField(header) {
            const headerLower = header.toLowerCase();
            return headerLower.includes('cost') || headerLower.includes('amount') || 
                   headerLower.includes('fee') || headerLower.includes('price') || 
                   headerLower.includes('premium') || headerLower.includes('rate');
        }

        function isDateField(header) {
            const headerLower = header.toLowerCase();
            return headerLower.includes('date') || 
                   headerLower.includes('dob') ||
                   headerLower.includes('enrolled') ||
                   headerLower.includes('hire') ||
                   headerLower.includes('start') ||
                   headerLower.includes('effective') ||
                   headerLower.includes('created') ||
                   headerLower.includes('modified');
        }

        // PRESERVED FUNCTIONALITY - Single Sheet Processing Functions (unchanged from v3.5)
        function shouldIncludeSSN(ssnRows, dateFields, costFields, targetDate, headers) {
            let hasNonZeroCost = false;
            let hasDateInRange = false;
            let hasZeroOrNullCost = false;
            let hasZeroOrNullDate = false;
            
            debugLog(`Evaluating SSN with ${ssnRows.length} rows`);
            
            for (const row of ssnRows) {
                for (const costField of costFields) {
                    const costIndex = headers.indexOf(costField.name);
                    if (costIndex !== -1) {
                        const costValue = row[costIndex];
                        if (isZeroOrNull(costValue)) {
                            hasZeroOrNullCost = true;
                            debugLog(`  Found zero/null cost in ${costField.name}`);
                        } else if (parseFloat(costValue) > 0) {
                            hasNonZeroCost = true;
                        }
                    }
                }
                
                for (const dateField of dateFields) {
                    const dateIndex = headers.indexOf(dateField.name);
                    if (dateIndex !== -1) {
                        const dateValue = row[dateIndex];
                        if (isZeroOrNull(dateValue)) {
                            hasZeroOrNullDate = true;
                            debugLog(`  Found zero/null date in ${dateField.name}`);
                        } else if (isDateMatch(dateValue, targetDate)) {
                            hasDateInRange = true;
                            debugLog(`  Found date match in ${dateField.name}`);
                        }
                    }
                }
            }
            
            const shouldExclude = hasNonZeroCost && !hasDateInRange && !hasZeroOrNullCost && !hasZeroOrNullDate;
            const shouldInclude = !shouldExclude;
            
            debugLog(`  Decision: ${shouldInclude ? 'INCLUDE' : 'EXCLUDE'} (nonZeroCost: ${hasNonZeroCost}, dateInRange: ${hasDateInRange}, zeroNullCost: ${hasZeroOrNullCost}, zeroNullDate: ${hasZeroOrNullDate})`);
            
            return shouldInclude;
        }

        function consolidateSSNRows(rows, headers) {
            if (rows.length === 0) return {};
            if (rows.length === 1) return rows[0];
            
            const consolidatedRow = {};
            let totalDollarAmount = 0;
            
            const costFields = headers.filter(header => isCostField(header));
            const planFields = headers.filter(header => isPlanField(header));
            
            headers.forEach(header => {
                const values = rows.map(row => row[header]).filter(val => val !== null && val !== undefined && val !== '');
                
                if (values.length === 0) {
                    consolidatedRow[header] = '';
                    return;
                }
                
                if (isDateField(header)) {
                    const validDates = values.filter(val => {
                        const parsed = parseExcelDate(val);
                        return parsed && !isNaN(parsed.getTime());
                    });
                    
                    consolidatedRow[header] = validDates.length > 0 ? validDates[0] : values[0];
                    return;
                }
                
                const dollarValues = values.filter(val => isDollarValue(val));
                if (dollarValues.length > 0 && costFields.includes(header)) {
                    const sum = dollarValues.reduce((acc, val) => acc + parseFloat(val), 0);
                    totalDollarAmount += sum;
                    consolidatedRow[header] = sum;
                } else if (planFields.includes(header)) {
                    const planCostPairs = [];
                    
                    rows.forEach(row => {
                        const planName = row[header];
                        if (planName && planName !== '') {
                            let correspondingCost = null;
                            
                            for (const costField of costFields) {
                                const costValue = row[costField];
                                if (costValue && isDollarValue(costValue)) {
                                    correspondingCost = parseFloat(costValue);
                                    break;
                                }
                            }
                            
                            if (correspondingCost !== null) {
                                planCostPairs.push(`${planName} (${correspondingCost.toFixed(2)})`);
                            } else {
                                planCostPairs.push(String(planName));
                            }
                        }
                    });
                    
                    const uniquePlanCostPairs = [...new Set(planCostPairs)];
                    consolidatedRow[header] = uniquePlanCostPairs.join(' | ');
                    
                } else {
                    const uniqueValues = [...new Set(values.map(val => String(val)))];
                    
                    if (uniqueValues.length === 1) {
                        consolidatedRow[header] = values[0];
                    } else {
                        consolidatedRow[header] = uniqueValues.join(' | ');
                    }
                }
            });
            
            consolidatedRow._isConsolidated = true;
            consolidatedRow._originalRowCount = rows.length;
            consolidatedRow._totalDollarAmount = totalDollarAmount;
            
            return consolidatedRow;
        }

        function processDataBySSN(data, headers, ssnField, dateFields, costFields, targetDate) {
            const ssnGroups = {};
            const consolidatedRows = [];
            let includedSSNs = 0;
            let excludedSSNs = 0;
            const matchingSSNs = new Set();
            
            const ssnIndex = headers.indexOf(ssnField);
            if (ssnIndex === -1) {
                throw new Error(`SSN field "${ssnField}" not found in headers`);
            }
            
            debugLog(`=== PROCESSING VERSION 3.7 - SINGLE SHEET MODE (UNCHANGED) ===`);
            debugLog(`Processing ${data.length - 1} data rows`);
            debugLog(`Target date: ${targetDate.toLocaleDateString()}`);
            
            for (let i = 1; i < data.length; i++) {
                const row = data[i];
                const ssn = formatSSN(row[ssnIndex]);
                if (!ssn) continue;
                
                if (!ssnGroups[ssn]) {
                    ssnGroups[ssn] = [];
                }
                ssnGroups[ssn].push(row);
            }
            
            debugLog(`Found ${Object.keys(ssnGroups).length} unique SSNs`);
            
            for (const [ssn, rows] of Object.entries(ssnGroups)) {
                if (shouldIncludeSSN(rows, dateFields, costFields, targetDate, headers)) {
                    matchingSSNs.add(ssn);
                    includedSSNs++;
                    
                    const processedRows = rows.map(row => {
                        const processedRow = {};
                        headers.forEach((header, index) => {
                            processedRow[header] = row[index];
                        });
                        return processedRow;
                    });
                    
                    const consolidatedRow = consolidateSSNRows(processedRows, headers);
                    consolidatedRows.push(consolidatedRow);
                } else {
                    excludedSSNs++;
                }
            }
            
            debugLog(`=== FINAL RESULTS ===`);
            debugLog(`Included SSNs: ${includedSSNs}, Excluded SSNs: ${excludedSSNs}`);
            debugLog(`Total consolidated rows: ${consolidatedRows.length}`);
            
            return { 
                ssnGroups: Object.fromEntries(Array.from(matchingSSNs).map(ssn => [ssn, ssnGroups[ssn]])),
                matchingRows: consolidatedRows,
                originalRowCount: Array.from(matchingSSNs).reduce((sum, ssn) => sum + ssnGroups[ssn].length, 0),
                stats: {
                    includedSSNs,
                    excludedSSNs
                }
            };
        }

        async function processEnrollmentData() {
            try {
                debugLog('Starting processEnrollmentData function...');
                
                updateStepIndicators('process');
                showStatus('Processing enrollment data...', 'info');
                updateProgress(10);
                
                if (currentSheetData.length === 0) {
                    showStatus('No data to process. Please run Step 1: Analyze first.', 'error');
                    return;
                }
                
                if (selectedSSNFields.length !== 1) {
                    showStatus('Please select exactly one SSN field.', 'error');
                    return;
                }
                
                if (!policyChangeDate) {
                    showStatus('Please select a policy change date.', 'error');
                    return;
                }
                
                await Excel.run(async (context) => {
                    updateProgress(25);
                    
                    const processedData = processDataBySSN(
                        currentSheetData, 
                        detectedHeaders, 
                        selectedSSNFields[0], 
                        detectedDateFields,
                        detectedCostFields,
                        policyChangeDate
                    );
                    
                    updateProgress(50);
                    
                    await createPolicyChangesSheetWithRetry(context, processedData.ssnGroups, detectedHeaders);
                    
                    updateProgress(75);
                    
                    await createSummarySheet(context, processedData, selectedSSNFields[0], detectedDateFields, detectedCostFields);
                    
                    updateProgress(90);
                    
                    updateStepIndicators('completed');
                    showStatus(`Processing complete! Found ${processedData.matchingRows.length} matching records.`, 'success');
                    
                    updateProgress(100);
                    setTimeout(() => updateProgress(0), 1000);
                });
            } catch (error) {
                showStatus('Error processing data: ' + error.message, 'error');
                debugLog('Processing error: ' + error.message);
                updateProgress(0);
            }
        }

        // PRESERVED FUNCTIONALITY - Sheet Creation Functions (unchanged from v3.5)
        async function createPolicyChangesSheetWithRetry(context, ssnGroups, originalHeaders, maxRetries = 3) {
            for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                    await createPolicyChangesSheet(context, ssnGroups, originalHeaders);
                    return;
                } catch (error) {
                    if (attempt === maxRetries) {
                        throw new Error(`Failed to create Policy Changes sheet after ${maxRetries} attempts: ${error.message}`);
                    }
                    
                    const delay = Math.pow(2, attempt - 1) * 1000;
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
        }

        async function createPolicyChangesSheet(context, ssnGroups, originalHeaders) {
            try {
                const worksheets = context.workbook.worksheets;
                const sheetName = "Policy Changes to Note";
                
                try {
                    const existingSheet = worksheets.getItem(sheetName);
                    existingSheet.delete();
                    await context.sync();
                } catch (deleteError) {
                    // Sheet doesn't exist
                }
                
                const newSheet = worksheets.add(sheetName);
                await context.sync();
                
                if (Object.keys(ssnGroups).length === 0) {
                    const noDataRange = newSheet.getRange("A1");
                    noDataRange.values = [["No policy changes found matching the enhanced criteria"]];
                    noDataRange.format.font.bold = true;
                    await context.sync();
                    return;
                }
                
                const enhancedHeaders = [...originalHeaders];
                enhancedHeaders.push('CONSOLIDATED_ROWS');
                enhancedHeaders.push('TOTAL_DOLLAR_AMOUNT');
                enhancedHeaders.push('CONSOLIDATION_NOTES');
                
                const headerRange = newSheet.getRange(`A1:${getExcelColumnName(enhancedHeaders.length)}1`);
                headerRange.values = [enhancedHeaders];
                headerRange.format.font.bold = true;
                headerRange.format.fill.color = "#0078d4";
                headerRange.format.font.color = "white";
                await context.sync();
                
                let currentRow = 2;
                
                for (const [ssn, rows] of Object.entries(ssnGroups)) {
                    const processedRows = rows.map(row => {
                        const processedRow = {};
                        originalHeaders.forEach((header, index) => {
                            processedRow[header] = row[index];
                        });
                        return processedRow;
                    });
                    
                    const consolidatedRow = consolidateSSNRows(processedRows, originalHeaders);
                    
                    const rowData = originalHeaders.map(header => {
                        let value = consolidatedRow[header];
                        if (value === undefined || value === null) {
                            return '';
                        }
                        
                        if (isDateField(header) && value !== '') {
                            const excelDate = formatDateForExcel(value);
                            return excelDate !== '' ? excelDate : value;
                        }
                        
                        return value;
                    });
                    
                    rowData.push(consolidatedRow._originalRowCount || 1);
                    rowData.push(consolidatedRow._totalDollarAmount || 0);
                    
                    let notes = '';
                    if (consolidatedRow._originalRowCount > 1) {
                        notes = `Consolidated ${consolidatedRow._originalRowCount} rows using enhanced v3.7 logic. `;
                        notes += 'Plan/coverage fields show individual plan costs as "Plan Name ($Cost)".';
                    } else {
                        notes = 'Single row - no consolidation needed';
                    }
                    rowData.push(notes);
                    
                    const rowRange = newSheet.getRange(`A${currentRow}:${getExcelColumnName(enhancedHeaders.length)}${currentRow}`);
                    rowRange.values = [rowData];
                    
                    originalHeaders.forEach((header, headerIndex) => {
                        if (isDateField(header)) {
                            const cellRange = newSheet.getRange(`${getExcelColumnName(headerIndex + 1)}${currentRow}`);
                            cellRange.numberFormat = [["mm/dd/yyyy"]];
                        }
                    });
                    
                    const dollarAmountColIndex = enhancedHeaders.length - 1;
                    const dollarRange = newSheet.getRange(`${getExcelColumnName(dollarAmountColIndex)}${currentRow}`);
                    dollarRange.numberFormat = [["$#,##0.00"]];
                    
                    if (consolidatedRow._originalRowCount > 1) {
                        rowRange.format.fill.color = "#E3F2FD";
                        dollarRange.format.font.bold = true;
                        dollarRange.format.fill.color = "#FFEB3B";
                    }
                    
                    currentRow++;
                    
                    if (currentRow % 25 === 0) {
                        await context.sync();
                    }
                }
                
                await context.sync();
                
                try {
                    newSheet.getUsedRange().format.autofitColumns();
                    await context.sync();
                } catch (autofitError) {
                    debugLog('Auto-fit failed: ' + autofitError.message);
                }
                
                const summaryStartRow = currentRow + 2;
                const summaryData = [
                    ['PROCESSING SUMMARY v3.7 CONCEPT CHANGE', ''],
                    ['Total Unique SSNs:', Object.keys(ssnGroups).length],
                    ['Total Original Rows:', Object.values(ssnGroups).reduce((sum, rows) => sum + rows.length, 0)],
                    ['Total Consolidated Rows:', Object.keys(ssnGroups).length],
                    ['Logic Version:', 'Enhanced v3.7 - Concept change for Open Enrollment mode'],
                    ['Single Sheet Mode:', 'Data consolidation with enhanced filtering logic (UNCHANGED)'],
                    ['Open Enrollment Mode:', 'Copy ALL rows from Sheet 1 where SSN in both sheets OR policy matches'],
                    ['Processing Date:', new Date().toLocaleDateString()],
                    ['Processing Time:', new Date().toLocaleTimeString()]
                ];
                
                for (let i = 0; i < summaryData.length; i++) {
                    const summaryRange = newSheet.getRange(`A${summaryStartRow + i}:B${summaryStartRow + i}`);
                    summaryRange.values = [summaryData[i]];
                    
                    if (i === 0) {
                        summaryRange.format.font.bold = true;
                        summaryRange.format.fill.color = "#4CAF50";
                        summaryRange.format.font.color = "white";
                    }
                }
                
                await context.sync();
                newSheet.activate();
                await context.sync();
                
            } catch (error) {
                debugLog('Policy changes sheet creation failed: ' + error.message);
                throw error;
            }
        }

        async function createSummarySheet(context, processedData, ssnField, dateFields, costFields) {
            try {
                debugLog('Starting summary sheet creation...');
                
                const existingSheet = context.workbook.worksheets.getItemOrNullObject("Processing Summary");
                await context.sync();
                
                if (!existingSheet.isNullObject) {
                    existingSheet.delete();
                    await context.sync();
                }
                
                const summarySheet = context.workbook.worksheets.add("Processing Summary");
                await context.sync();
                
                const totalOriginalRows = processedData.originalRowCount || 0;
                const totalConsolidatedRows = processedData.matchingRows.length;
                const totalSSNs = Object.keys(processedData.ssnGroups).length;
                
                let totalDollarAmount = 0;
                let consolidatedRowsCount = 0;
                
                processedData.matchingRows.forEach(row => {
                    if (row._totalDollarAmount) {
                        totalDollarAmount += row._totalDollarAmount;
                    }
                    if (row._originalRowCount > 1) {
                        consolidatedRowsCount++;
                    }
                });
                
                const summaryData = [
                    ["Enrollment Data Processing Summary v3.7 CONCEPT CHANGE", ""],
                    ["", ""],
                    ["BASIC INFORMATION", ""],
                    ["Policy Change Date", policyChangeDate.toLocaleDateString()],
                    ["Selected SSN Field", ssnField],
                    ["Date Fields Scanned", dateFields.map(f => f.name).join(", ")],
                    ["Cost Fields Scanned", costFields.map(f => f.name).join(", ")],
                    ["", ""],
                    ["DATA PROCESSING RESULTS", ""],
                    ["Total Original Rows Found", totalOriginalRows],
                    ["Total Consolidated Rows Created", totalConsolidatedRows],
                    ["Unique SSNs Processed", totalSSNs],
                    ["SSNs Included", processedData.stats?.includedSSNs || 0],
                    ["SSNs Excluded", processedData.stats?.excludedSSNs || 0],
                    ["SSNs with Multiple Rows", consolidatedRowsCount],
                    ["SSNs with Single Row", totalSSNs - consolidatedRowsCount],
                    ["", ""],
                    ["FINANCIAL SUMMARY", ""],
                    ["Total Dollar Amount", totalDollarAmount],
                    ["Average per SSN", totalSSNs > 0 ? (totalDollarAmount / totalSSNs) : 0],
                    ["", ""],
                    ["PROCESSING LOGIC v3.7", ""],
                    ["Single Sheet Mode", "EXCLUDE SSNs where ALL rows have cost > $0 AND ALL date fields NOT in target range (UNCHANGED)"],
                    ["Open Enrollment Mode v3.7", "Copy ALL rows from Sheet 1 where SSN exists in BOTH sheets OR fuzzy matching finds policy matches"],
                    ["Single Sheet Consolidation", "Multiple rows per SSN consolidated with cost summation"],
                    ["Open Enrollment Copy", "ALL rows copied exactly as-is, no consolidation"],
                    ["Healthcare Matching", "Uses fuzzy matching with healthcare abbreviation expansion"],
                    ["Date Processing", "Maintains proper Excel date formatting"],
                    ["", ""],
                    ["PROCESSING METADATA", ""],
                    ["Processing Date", new Date().toLocaleDateString()],
                    ["Processing Time", new Date().toLocaleTimeString()],
                    ["Debug Mode", debugMode ? "Enabled" : "Disabled"],
                    ["Version", "3.7 CONCEPT CHANGE - Open Enrollment copies ALL matching rows from Sheet 1"]
                ];
                
                for (let i = 0; i < summaryData.length; i++) {
                    const rowRange = summarySheet.getRange(`A${i + 1}:B${i + 1}`);
                    rowRange.values = [summaryData[i]];
                    
                    const content = summaryData[i][0];
                    if (content.includes("Processing Summary")) {
                        rowRange.merge();
                        rowRange.format.font.bold = true;
                        rowRange.format.font.size = 14;
                        rowRange.format.fill.color = "#0078d4";
                        rowRange.format.font.color = "white";
                        rowRange.format.horizontalAlignment = "Center";
                    } else if (content.includes("INFORMATION") || content.includes("RESULTS") || content.includes("SUMMARY") || content.includes("LOGIC") || content.includes("METADATA")) {
                        rowRange.format.font.bold = true;
                        rowRange.format.fill.color = "#E3F2FD";
                        rowRange.format.font.color = "#1976D2";
                    }
                }
                
                const dollarRows = [19, 20];
                dollarRows.forEach(rowNum => {
                    if (rowNum <= summaryData.length) {
                        const cellRange = summarySheet.getRange(`B${rowNum}`);
                        cellRange.numberFormat = [["$#,##0.00"]];
                    }
                });
                
                await context.sync();
                summarySheet.getUsedRange().format.autofitColumns();
                await context.sync();
                
            } catch (error) {
                debugLog('Summary sheet creation failed: ' + error.message);
                throw error;
            }
        }

        function getExcelColumnName(columnNumber) {
            let columnName = '';
            while (columnNumber > 0) {
                const remainder = (columnNumber - 1) % 26;
                columnName = String.fromCharCode(65 + remainder) + columnName;
                columnNumber = Math.floor((columnNumber - 1) / 26);
            }
            return columnName;
        }

        // PRESERVED FUNCTIONALITY - Keyboard shortcuts (unchanged from v3.5)
        document.addEventListener('keydown', (event) => {
            if (event.ctrlKey && event.altKey && event.key === '1') {
                event.preventDefault();
                if (officeReady) analyzeCurrentSheet();
            }
            
            if (event.ctrlKey && event.altKey && event.key === '2') {
                event.preventDefault();
                if (officeReady && selectedSSNFields.length === 1) processEnrollmentData();
            }
            
            if (event.ctrlKey && event.altKey && event.key === '3') {
                event.preventDefault();
                if (officeReady && hasSSNInBothSheets) runOpenEnrollmentProcess();
            }
        });

        console.log('=== SCRIPT LOADED COMPLETELY - VERSION 3.7 CONCEPT CHANGE ===');
        console.log('Major Change in v3.7:');
        console.log('- OPEN ENROLLMENT CONCEPT CHANGE: Copy ALL rows from Sheet 1 where SSN exists in BOTH sheets OR fuzzy matching finds policy matches');
        console.log('- NO CONSOLIDATION in Open Enrollment: All rows copied exactly as they appear in Sheet 1');
        console.log('- DUAL LOGIC: Single sheet (with consolidation) vs Open Enrollment (exact copy)');
        console.log('- PRESERVED FUZZY MATCHING: Uses existing healthcare abbreviation expansion and similarity algorithms');
        console.log('Preserved v3.5 Features:');
        console.log('- SINGLE SHEET FUNCTIONALITY: All existing single-sheet processing preserved unchanged');
        console.log('- ALL-SHEET SCANNING: Analyzes every worksheet in the workbook');
        console.log('- INTELLIGENT SHEET SELECTION: Automatically selects first two sheets with SSN data');
        console.log('- DATA-BASED SSN DETECTION: Scans actual column data for SSN patterns');
        console.log('- Supported SSN Patterns: XXX-XX-XXXX, XXXXXXXXX, XXX XX XXXX, XXX XXXXXX');
        console.log('- Visual Indicators: Green highlighting for data-detected fields');
        console.log('- Healthcare abbreviation expansion with fuzzy matching');
        console.log('- Radio button validation and UI state management');
        console.log('=== READY FOR USE - CONCEPT CHANGE IMPLEMENTED ===');
    </script>
</body>
</html>